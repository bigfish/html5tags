<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang="en"><head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <title>WebGL Specification</title>
    <meta name="generator" content="BBEdit 9.1">
    <link rel="stylesheet" type="text/css" href="/webgl/index_files/Khronos-WD.css">
    <link rel="stylesheet" type="text/css" href="/webgl/index_files/default.css">
    <script src="/webgl/index_files/jquery-1.js" type="text/javascript"></script>
    <script src="/webgl/index_files/generateTOC.js" type="text/javascript"></script>
</head>
<body onload="generateTOC(document.getElementById('toc'))">
    <!--begin-logo-->
    <div class="head">
        <p>
            <a href="http://khronos.org/">
                <img alt="Khronos" src="/webgl/index_files/KhronosGroup-3D.png" height="60" width="220">
            </a>
        </p>
    </div>
    <div class="head">
        <p>
            <a href="http://webgl.org/">
                <img alt="WebGL" src="/webgl/index_files/WebGL-Logo.png" height="72" width="156">
            </a>
        </p>
    </div>
    <!--end-logo-->
    
    <h1>WebGL Specification</h1>
    <h2 class="no-toc">Working Draft 10 June 2010</h2>
    <dl>
        <dt>This version:
            </dt><dd>
                <a href="/webgl/">
                    /webgl/
                </a>
                <br>
                <a href="https://cvs.khronos.org/svn/repos/registry/trunk/public/webgl/doc/spec/webgl.idl">
                    <b>WebIDL:</b> https://cvs.khronos.org/svn/repos/registry/trunk/public/webgl/doc/spec/webgl.idl
                </a>
            </dd>
        <dt>Latest version:
            </dt><dd>
                <a href="/webgl/">
                    /webgl/
                </a>
                <br>
                <a href="https://cvs.khronos.org/svn/repos/registry/trunk/public/webgl/doc/spec/webgl.idl">
                    <b>WebIDL:</b> https://cvs.khronos.org/svn/repos/registry/trunk/public/webgl/doc/spec/webgl.idl
                </a>
            </dd>
        <dt>Previous version:
            </dt><dd>
                    none
            </dd>
        <dt>Editor:
            </dt><dd>
                <a href="mailto:cmarrin@apple.com">Chris Marrin</a>
                <a href="http://www.apple.com/">(Apple Inc.)</a>
            </dd>
    </dl>
    
    <span style="font-size: x-small; font-style: oblique;">Copyright © 2010 Khronos Group</span>

    <hr>
    
    <h2 class="no-toc">Abstract</h2>
    <p>
        This specification describes an additional rendering context and support
        objects for the
        <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html" title="HTML 5 Canvas Element">
            HTML 5 <span class="prop-name">canvas</span> element.
        </a>
        This context allows rendering using an API that conforms closely to the OpenGL ES 2.0 API.
    </p>

    <h2 class="no-toc">Status of this document</h2>
    
    <!--begin-status-->
    <p>
        This is a working draft document and may be updated, replaced or obsoleted 
        by other documents at any time. Do not cite this document 
        as other than work in progress.  Public discussion of this draft specification 
        is welcome on the (<a href="https://www.khronos.org/webgl/public-mailing-list/archives/">archived</a>) 
        WebGL mailing list <a href="mailto:public_webgl@khronos.org">public_webgl@khronos.org</a> (see
        <a href="http://www.khronos.org/webgl/public-mailing-list/">instructions</a>).
    </p>
    <!--end-status-->
    
    <h2 class="no-toc">Table of contents</h2>
    <div id="toc"><ul class="toc">
<li class="toc-h2"><a href="#1"><span class="secno">1</span>Introduction</a></li>
<li class="toc-h2"><a href="#2"><span class="secno">2</span>Context Creation and Drawing Buffer Presentation</a></li>
<li class="toc-h3"><a href="#2.1"><span class="secno">2.1</span>The <span class="prop-name">‘<code class="property">canvas</code>’</span> Element</a></li>
<li class="toc-h3"><a href="#2.2"><span class="secno">2.2</span>The Drawing Buffer</a></li>
<li class="toc-h3"><a href="#2.3"><span class="secno">2.3</span>The WebGL Viewport</a></li>
<li class="toc-h3"><a href="#2.4"><span class="secno">2.4</span>Premultiplied Alpha, Canvas APIs and texImage2D</a></li>
<li class="toc-h2"><a href="#3"><span class="secno">3</span>WebGL Resources</a></li>
<li class="toc-h2"><a href="#4"><span class="secno">4</span>Security</a></li>
<li class="toc-h3"><a href="#4.1"><span class="secno">4.1</span>Resource Restrictions</a></li>
<li class="toc-h3"><a href="#4.2"><span class="secno">4.2</span>Origin Restrictions</a></li>
<li class="toc-h3"><a href="#4.3"><span class="secno">4.3</span>Supported GLSL Constructs</a></li>
<li class="toc-h3"><a href="#4.4"><span class="secno">4.4</span>Defense Against Denial of Service</a></li>
<li class="toc-h2"><a href="#5"><span class="secno">5</span>DOM Interfaces</a></li>
<li class="toc-h3"><a href="#5.1"><span class="secno">5.1</span>Types</a></li>
<li class="toc-h3"><a href="#5.2"><span class="secno">5.2</span>WebGLContextAttributes</a></li>
<li class="toc-h4"><a href="#5.2.1"><span class="secno">5.2.1</span>Context creation parameters</a></li>
<li class="toc-h3"><a href="#5.3"><span class="secno">5.3</span>WebGLObject</a></li>
<li class="toc-h3"><a href="#5.4"><span class="secno">5.4</span>WebGLBuffer</a></li>
<li class="toc-h3"><a href="#5.5"><span class="secno">5.5</span>WebGLFramebuffer</a></li>
<li class="toc-h3"><a href="#5.6"><span class="secno">5.6</span>WebGLProgram</a></li>
<li class="toc-h3"><a href="#5.7"><span class="secno">5.7</span>WebGLRenderbuffer</a></li>
<li class="toc-h3"><a href="#5.8"><span class="secno">5.8</span>WebGLShader</a></li>
<li class="toc-h3"><a href="#5.9"><span class="secno">5.9</span>WebGLTexture</a></li>
<li class="toc-h3"><a href="#5.10"><span class="secno">5.10</span>WebGLUniformLocation</a></li>
<li class="toc-h3"><a href="#5.11"><span class="secno">5.11</span>WebGLActiveInfo</a></li>
<li class="toc-h4"><a href="#5.11.1"><span class="secno">5.11.1</span>Attributes</a></li>
<li class="toc-h3"><a href="#5.12"><span class="secno">5.12</span>ArrayBuffer and Typed Arrays</a></li>
<li class="toc-h3"><a href="#5.13"><span class="secno">5.13</span>The WebGL context</a></li>
<li class="toc-h4"><a href="#5.13.1"><span class="secno">5.13.1</span>Attributes</a></li>
<li class="toc-h4"><a href="#5.13.2"><span class="secno">5.13.2</span>The <code>getContextAttributes</code> method</a></li>
<li class="toc-h4"><a href="#5.13.3"><span class="secno">5.13.3</span>Setting and getting state</a></li>
<li class="toc-h4"><a href="#5.13.4"><span class="secno">5.13.4</span>Viewing and clipping</a></li>
<li class="toc-h4"><a href="#5.13.5"><span class="secno">5.13.5</span>Buffer objects</a></li>
<li class="toc-h4"><a href="#5.13.6"><span class="secno">5.13.6</span>Framebuffer objects</a></li>
<li class="toc-h4"><a href="#5.13.7"><span class="secno">5.13.7</span>Renderbuffer objects</a></li>
<li class="toc-h4"><a href="#5.13.8"><span class="secno">5.13.8</span>Texture objects</a></li>
<li class="toc-h4"><a href="#5.13.9"><span class="secno">5.13.9</span>Programs and Shaders</a></li>
<li class="toc-h4"><a href="#5.13.10"><span class="secno">5.13.10</span>Uniforms and attributes</a></li>
<li class="toc-h4"><a href="#5.13.11"><span class="secno">5.13.11</span>Writing to the drawing buffer</a></li>
<li class="toc-h4"><a href="#5.13.12"><span class="secno">5.13.12</span>Reading back pixels</a></li>
<li class="toc-h4"><a href="#5.13.13"><span class="secno">5.13.13</span>Detecting context lost events</a></li>
<li class="toc-h4"><a href="#5.13.14"><span class="secno">5.13.14</span>Detecting and enabling extensions</a></li>
<li class="toc-h3"><a href="#5.14"><span class="secno">5.14</span>Events</a></li>
<li class="toc-h4"><a href="#5.14.1"><span class="secno">5.14.1</span>WebGLContextLostEvent</a></li>
<li class="toc-h5"><a href="#5.14.1.1"><span class="secno">5.14.1.1</span>Attributes</a></li>
<li class="toc-h5"><a href="#5.14.1.2"><span class="secno">5.14.1.2</span>Methods</a></li>
<li class="toc-h4"><a href="#5.14.2"><span class="secno">5.14.2</span>WebGLContextRestoredEvent</a></li>
<li class="toc-h5"><a href="#5.14.2.1"><span class="secno">5.14.2.1</span>Attributes</a></li>
<li class="toc-h5"><a href="#5.14.2.2"><span class="secno">5.14.2.2</span>Methods</a></li>
<li class="toc-h2"><a href="#6"><span class="secno">6</span>Differences Between WebGL and OpenGL ES 2.0</a></li>
<li class="toc-h3"><a href="#6.1"><span class="secno">6.1</span>Buffer Object Binding</a></li>
<li class="toc-h3"><a href="#6.2"><span class="secno">6.2</span>Enabled Vertex Attributes and Range Checking</a></li>
<li class="toc-h3"><a href="#6.3"><span class="secno">6.3</span>Framebuffer Object Attachments</a></li>
<li class="toc-h3"><a href="#6.4"><span class="secno">6.4</span>Pixel Storage Parameters</a></li>
<li class="toc-h3"><a href="#6.5"><span class="secno">6.5</span>Stencil Separate Mask and Reference Value</a></li>
<li class="toc-h3"><a href="#6.6"><span class="secno">6.6</span>Vertex Attribute Data Stride</a></li>
<li class="toc-h3"><a href="#6.7"><span class="secno">6.7</span>Viewport Depth Range</a></li>
<li class="toc-h3"><a href="#6.8"><span class="secno">6.8</span>Blending With Constant Color</a></li>
<li class="toc-h3"><a href="#6.9"><span class="secno">6.9</span>Fixed point support</a></li>
<li class="toc-h3"><a href="#6.10"><span class="secno">6.10</span>GLSL Constructs</a></li>
<li class="toc-h3"><a href="#6.11"><span class="secno">6.11</span>Extension Queries</a></li>
<li class="toc-h2"><a href="#7"><span class="secno">7</span>References</a></li>
<li class="toc-h3"><a href="#7.1"><span class="secno">7.1</span>Normative references</a></li>
<li class="toc-h3"><a href="#7.2"><span class="secno">7.2</span>Other references</a></li>
<li class="toc-h2"><a href="#8"><span class="secno">8</span>Acknowledgments</a></li>
</ul></div>

    <h2 id="1"><span class="secno">1</span> Introduction</h2>
    <p>
        <em>This section is not normative.</em>
    </p>

    <p>
        The HTMLCanvasElement places an element on the page into which graphic
        images can be rendered using a programmatic interface. Currently the only
        such interface described is the CanvasRenderingContext2D. This document
        describes another such interface, WebGLRenderingContext, which presents
        an API derived from the OpenGL ES 2.0 specification. This API provides a
        rich set of functions allowing realistic 3D graphics to be rendered.
    </p>
    <p>
        More details needed here...
    </p>

    <div class="issue">
        <p>
            This is where issues would go
        </p>
    </div>

<!-- ======================================================================================================= -->

    <h2 id="2"><span class="secno">2</span> Context Creation and Drawing Buffer Presentation</h2>

    <p>
        Before using the WebGL API, the author must obtain a WebGLRenderingContext object
        for a given HTMLCanvasElement as described below. This object is used to manage 
        OpenGL state and render to the drawing buffer, which must also be created at the time of
        context creation. The author may supply configuration options for this drawing buffer, otherwise
        default values shall be used as specified elsewhere in this document. This drawing buffer
        is presented to the HTML page compositor immediately before an HTML page compositing operation, 
        but only if the drawing buffer has been modified since the last compositing operation.
    </p>
    
<!-- ======================================================================================================= -->

    <h3 id="2.1"><span class="secno">2.1</span> The <span class="prop-name">‘<code class="property">canvas</code>’</span> Element</h3>

    <p>
        A WebGLRenderingContext object shall be created by calling the getContext() method of 
        a given HTMLCanvasElement object with the exact string ‘<code class="property">webgl</code>’. 
        This string is case sensitive. When called for the first time, a 
        WebGLRenderingContext object is created and returned. Also at this time a drawing buffer
        shall be created. Subsequent calls to getContext() with the same string shall return the same object. 
        If getContext() is subsequently called with any other string, the WebGLRenderingContext shall 
        be detached from its Canvas object (the <code>canvas</code> attribute will be null). API calls may
        still be made on the WebGLRenderingContext object and readPixels() may be used
        to obtain the contents of the drawing buffer, but the contents shall no longer be shown
        on the page.
    </p>
        A second parameter may be passed to the getContext() function. If passed, this parameter 
        shall be a WebGLContextAttributes object containing configuration parameters to be used in 
        creating the drawing buffer. See <a href="#WEBGLCONTEXTATTRIBUTES">WebGLContextAttributes</a> for
        more details. On subsequent calls to getContext() with the ‘<code class="property">webgl</code>’
        string, the passed WebGLContextAttributes object, if any, shall be ignored.
    <p>
    </p>
    
<!-- ======================================================================================================= -->

    <h3 id="2.2"><span class="secno">2.2</span> The Drawing Buffer</h3>

    <p>
        The drawing buffer into which the API calls are rendered shall be defined upon creation of
        the WebGLRenderingContext object. The size of this drawing buffer shall be determined by the
        <code>width</code> and <code>height</code> attributes of the HTMLCanvasElement. Changing
        either of these attributes shall cause the drawing buffer to resize and its contents to be
        cleared to (0,0,0,0).
    </p>
    <p>
        By default, the drawing buffer has an RGBA color buffer of at least 8 bits per component 
        and an integer depth buffer of at least 16 bits. The optional WebGLContextAttributes 
        object may be used to change these defaults. This object is only used on the first call
        to getContext. No facility is provided to change the attributes of the drawing buffer 
        after its creation.
    </p>
    <p>
        WebGL presents its drawing buffer to the HTML page compositor immediately before a compositing 
        operation, but only if the drawing buffer has been modified since the last compositing operation.
        Before the drawing buffer is presented for compositing the implementation shall ensure that all 
        rendering operations have been flushed to the drawing buffer. After compositing the contents of 
        the drawing buffer shall be undefined but must not contain uninitialized pixels.
    </p>
    
<!-- ======================================================================================================= -->

    <h3 id="2.3"><span class="secno">2.3</span> The WebGL Viewport</h3>

    <p>
        OpenGL manages a rectangular viewport as part of its state which defines the placement of the
        rendering results in the drawing buffer. Upon creation of the WebGL context, the viewport is
        initialized to a rectangle with origin at (0, 0) and width and height equal to (canvas.width,
        canvas.height).
    </p>
    <p>
        A WebGL implementation <em>shall not</em> affect the state of the OpenGL viewport in response to
        resizing of the canvas element.
    </p>
    <div class="example">
        Note that if a WebGL program does not contain logic to set the viewport, it will not properly
        handle the case where the canvas is resized. The following ECMAScript example illustrates how
        a WebGL program might resize the canvas programmatically.

        <pre>var canvas = document.getElementById('canvas1');
var gl = canvas.getContext('webgl');
canvas.width = newWidth;
canvas.height = newHeight;
gl.viewport(0, 0, canvas.width, canvas.height);
        </pre>
    </div>
    <p>
        <em>Rationale</em>: automatically setting the viewport will interfere with applications that set
        it manually. Applications are expected to use <code>onresize</code> handlers to respond to
        changes in size of the canvas and set the OpenGL viewport in turn.
    </p>

<!-- ======================================================================================================= -->

    <h3 id="2.4"><span class="secno">2.4</span> <a name="PREMULTIPLIED_ALPHA">Premultiplied Alpha, Canvas APIs and texImage2D</a></h3>

    <p>
        The OpenGL API allows the application to modify the blending modes used during rendering,
        and for this reason allows control over how alpha values in the drawing buffer are
        interpreted; see the <code>premultipliedAlpha</code> parameter in
        the <a href="#WEBGLCONTEXTATTRIBUTES">WebGLContextAttributes</a> section.
    </p>
    <p>
        The HTML Canvas APIs <code>toDataURL</code> and <code>drawImage</code> must respect
        the <code>premultipliedAlpha</code> context creation parameter. When <code>toDataURL</code>
        is called against a Canvas into which WebGL content is being rendered, then if the requested
        image format does not specify premultiplied alpha and the WebGL context has
        the <code>premultipliedAlpha</code> parameter set to true, then the pixel values must be
        de-multiplied; i.e., the color channels are divided by the alpha channel. <b>Note</b> that
        this operation is lossy.
    </p>
    <p>
        Passing a WebGL-rendered Canvas to the <code>drawImage</code> method
        of <code>CanvasRenderingContext2D</code> may or may not need to modify the the rendered
        WebGL content during the drawing operation, depending on the premultiplication needs of the
        <code>CanvasRenderingContext2D</code> implementation.
    </p>
    <p>
        When passing a WebGL-rendered Canvas to the <code>texImage2D</code> API, then depending on
        the setting of the <code>premultipliedAlpha</code> context creation parameter of the passed
        canvas and the <code>UNPACK_PREMULTIPLY_ALPHA_WEBGL</code> pixel store parameter of the
        destination WebGL context, the pixel data may need to be changed to or from premultiplied
        form.
    </p>

<!-- ======================================================================================================= -->

    <h2 id="3"><span class="secno">3</span> WebGL Resources</h2>

    <p> 
        OpenGL manages several types of resources as part of its state. These are identified
        by integer object names and are obtained from OpenGL by various creation calls.
        In contrast WebGL represents these resources as DOM objects. Each object is derived 
        from the WebGLObject interface. Currently supported resources are:
        textures, buffers (i.e., VBOs), framebuffers, renderbuffers, shaders and
        programs. The WebGLRenderingContext interface has a method to create a 
        WebGLObject subclass for each type. Data from the underlying graphics library are
        stored in these objects and are fully managed by them. The resources represented
        by these objects are guaranteed to exist as long as the object exists.
        Furthermore, the DOM object is guaranteed to exist as long as the author has an explicit
        valid reference to it OR as long as it is bound by the underlying graphics library.
        When none of these conditions exist the user agent can, at any point, delete the object 
        using the equivalent of a delete call (e.g., deleteTexture). If authors wish to control 
        when the underlying resource is released then the delete call can be made explicitly.
    </p>

<!-- ======================================================================================================= -->

    <h2 id="4"><span class="secno">4</span> Security</h2>

    <p> 
    </p>

<!-- ======================================================================================================= -->

    <h3 id="4.1"><span class="secno">4.1</span> Resource Restrictions</h3>

    <p>
        WebGL resources such as textures and vertex buffer objects (VBOs) must always 
        contain initialized data, even if they were created without initial user 
        data values.  Creating a resource without initial values is commonly used to 
        reserve space for a texture or VBO, which is then modified using <code>texSubImage</code> or 
        <code>bufferSubData</code> calls.  If initial data is not provided to these calls, 
        the WebGL implementation must initialize their contents 
        to 0.  For example, this may require creating a temporary buffer of 0 
        values the size of a requested VBO, so that it can be initialized 
        correctly.  All other forms of loading data into a texture or VBO 
        involve either ArrayBuffers or DOM objects such as images, 
        and are therefore already required to be initialized.
    </p>

    <p>
        When WebGL resources are accessed by shaders through a call such as
        <code>drawElements</code> or <code>drawArrays</code>, the WebGL implementation must ensure
        that the shader cannot access either out of bounds or uninitialized data.
        See <a href="#ATTRIBS_AND_RANGE_CHECKING">Enabled Vertex Attributes and Range Checking</a>
        for restrictions which must be enforced by the WebGL implementation.
    </p>

<!-- ======================================================================================================= -->

    <h3 id="4.2"><span class="secno">4.2</span> Origin Restrictions</h3>

    <p>
        In order to prevent information leakage, the HTML5 canvas element has
        a <i>origin-clean</i> flag.  (See HTML5, section 4.8.11.3, "Security with canvas
        elements".)  For a WebGL context, the <i>origin-clean</i> flag must be set to false
        if any of the following actions occur:
    </p>
        <ul>
            <li>The <code>texImage2D</code> method is called with an <code>HTMLImageElement</code> or 
                <code>HTMLVideoElement</code> whose origin is not the same as that of the Document 
                object that owns the canvas element.
            </li><li>The <code>texImage2D</code> method is called with an <code>HTMLCanvasElement</code> 
                whose <i>origin-clean</i> flag is set to false.
        </li></ul>
    <p>
        Whenever the <code>readPixels</code> method of the 2D context of a <code>canvas</code> 
        element whose <i>origin-clean</i> flag is set to false is called with otherwise correct 
        arguments, the method must raise a <code>SECURITY_ERR</code> exception.
    </p>

<!-- ======================================================================================================= -->

    <h3 id="4.3"><span class="secno">4.3</span> <a name="SUPPORTED_GLSL_CONSTRUCTS">Supported GLSL Constructs</a></h3>

    <p>
        A WebGL implementation must only accept shaders which conform to The OpenGL ES Shading
        Language, Version 1.00 <a href="#refsGLES20GLSL">[GLES20GLSL]</a>, and which do not exceed
        the minimum functionality mandated in Sections 4 and 5 of Appendix A.  In particular, a shader
        referencing state variables or functions that are available in other versions of GLSL (such
        as that found in versions of OpenGL for the desktop), must not be allowed to load.
    </p>
    <p>
        In addition to the reserved identifiers in the aforementioned specification, identifiers
        starting with "webgl_" and "_webgl_" are reserved for use by WebGL. A shader which declares
        a function, variable, structure name, or structure field starting with these prefixes must
        not be allowed to load.
    </p>

<!-- ======================================================================================================= -->

    <h3 id="4.4"><span class="secno">4.4</span> Defense Against Denial of Service</h3>

    <p>
    <i>This section is non-normative.</i>
    </p>

    <p>
    It is possible to create, either intentionally or unintentionally, combinations of shaders and
    geometry that take an undesirably long time to render. This issue is analogous to that of
    long-running scripts, for which user agents already have safeguards. However, long-running draw
    calls can cause loss of interactivity for the entire window system, not just the user agent.
    </p>

    <p>
    In the general case it is not possible to impose limits on the structure of incoming shaders to
    guard against this problem. Experimentation has shown that even very strict structural limits
    are insufficient to prevent long rendering times, and such limits would prevent shader authors
    from implementing common algorithms.
    </p>

    <p>
    User agents should implement safeguards to prevent excessively long rendering times and
    associated loss of interactivity. Suggested safeguards include:
    </p>

    <ul>

    <li> Splitting up draw calls with large numbers of elements into smaller draw calls.

    </li><li> Timing individual draw calls and forbidding further rendering from a page if a certain
         timeout is exceeded.

    </li><li> Using any watchdog facilities available at the user level, graphics API level, or operating
         system level to limit the duration of draw calls.

    </li><li> Separating the graphics rendering of the user agent into a distinct operating system
         process which can be terminated and restarted without losing application state.

    </li></ul>

    <p>
    The supporting infrastructure at the OS and graphics API layer is expected to improve over time,
    which is why the exact nature of these safeguards is not specified.
    </p>

<!-- ======================================================================================================= -->

    <h2 id="5"><span class="secno">5</span> DOM Interfaces</h2>

    <p>
        This section describes the interfaces and functionality added to the
        DOM to support runtime access to the functionality described above.
    </p>

<!-- ======================================================================================================= -->

    <h3 id="5.1"><span class="secno">5.1</span> Types</h3>

    <p>
        The following types are used in all interfaces in the following section.
    </p>
    <pre class="idl">typedef events::Event Event;
typedef html::HTMLCanvasElement HTMLCanvasElement;
typedef html::HTMLImageElement HTMLImageElement;
typedef html::HTMLVideoElement HTMLVideoElement;
typedef html::ImageData ImageData;

typedef unsigned long  GLenum;
typedef boolean        GLboolean;
typedef unsigned long  GLbitfield;
typedef byte           GLbyte;         /* 'byte' should be a signed 8 bit type. */
typedef short          GLshort;
typedef long           GLint;
typedef long           GLsizei;
typedef long           GLsizeiptr;
typedef unsigned byte  GLubyte;        /* 'unsigned byte' should be an unsigned 8 bit type. */
typedef unsigned short GLushort;
typedef unsigned long  GLuint;
typedef float          GLfloat;
typedef float          GLclampf;  
</pre>

<!-- ======================================================================================================= -->

    <h3 id="5.2"><span class="secno">5.2</span> <a name="WEBGLCONTEXTATTRIBUTES">WebGLContextAttributes</a></h3>

    <p>
        The <code>WebGLContextAttributes</code> interface contains drawing surface attributes 
        and is passed as the second parameter to getContext. A native object may be supplied
        as this parameter; the specified attributes will be queried from this object.
    </p>
    <pre class="idl">[Callback] interface <dfn id="WebGLContextAttributes">WebGLContextAttributes</dfn> {
    attribute boolean alpha;
    attribute boolean depth;
    attribute boolean stencil;
    attribute boolean antialias;
    attribute boolean premultipliedAlpha;
};</pre>

    <h4 id="5.2.1"><span class="secno">5.2.1</span> Context creation parameters</h4>

    <p>
        The following list describes each attribute in the WebGLContextAttributes object and
        its use. For each attribute the default value is shown. The default value is used
        either if no second parameter is passed to getContext, or if a native object is passed
        which has no attribute of the given name.
    </p>
    <dl>
        <dt><span class="prop-value">alpha</span></dt>
            <dd>
                <em>Default: true</em>. If the value is true, the drawing buffer has an alpha
                channel for the purposes of performing OpenGL destination alpha operations and
                compositing with the page. If the value is false, no alpha buffer is available.
            </dd>
        <dt> <span class="prop-value">depth</span>
            </dt><dd>
                <em>Default: true</em>. If the value is true, the drawing buffer has a depth
                buffer of at least 16 bits. If the value is false, no depth buffer is
                available.
           </dd>
        <dt> <span class="prop-value">stencil</span>
            </dt><dd>
                <em>Default: false</em>. If the value is true, the drawing buffer has a stencil
                buffer of at least 8 bits. If the value is false, no stencil buffer is
                available.
            </dd>
        <dt> <span class="prop-value">antialias</span>
            </dt><dd>
                <em>Default: true</em>. If the value is true and the implementation supports
                antialiasing the drawing buffer will perform antialiasing using its choice of
                technique (multisample/supersample) and quality. If the value is false or the
                implementation does not support antialiasing, no antialiasing is performed.
            </dd>
        <dt> <span class="prop-value">premultipliedAlpha</span>
            </dt><dd>
                <em>Default: true</em>. If the value is true the page compositor will assume the
                drawing buffer contains colors with premultiplied alpha. If the value is false the
                page compositor will assume that colors in the drawing buffer are not
                premultiplied. This flag is ignored if the <strong>alpha</strong> flag is
                false. See <a href="#PREMULTIPLIED_ALPHA">Premultiplied Alpha</a> for more
                information on the effects of the <code>premultipliedAlpha</code> flag.
            </dd>
    </dl>

    <div class="example">
    Here is an ECMAScript example which passes a WebGLContextAttributes argument to getContext.
    It assumes the presence of a canvas element named "canvas1" on the page.

    <pre>var canvas = document.getElementById('canvas1');
var context = canvas.getContext('webgl',
                                { antialias: false,
                                  stencil: true });
    </pre>
    </div>

<!-- ======================================================================================================= -->

    <h3 id="5.3"><span class="secno">5.3</span> WebGLObject</h3>

    <p>
        The <code>WebGLObject</code> interface is the parent interface for all GL objects.
    </p>
    <pre class="idl">interface <dfn id="WebGLObject">WebGLObject</dfn> {
};</pre>

<!-- ======================================================================================================= -->

    <h3 id="5.4"><span class="secno">5.4</span> WebGLBuffer</h3>

    <p>
        The <code>WebGLBuffer</code> interface represents an OpenGL Buffer Object. The
        underlying object is created as if by calling 
        <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glGenBuffers.xml">
            glGenBuffers
        </a>
        , bound as if by calling
        <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glBindBuffer.xml">
        glBindBuffer 
        </a>
        and destroyed as if by calling 
        <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glDeleteBuffers.xml">
        glDeleteBuffers.
        </a>
    </p>
    <pre class="idl">interface <dfn id="WebGLBuffer">WebGLBuffer</dfn> : WebGLObject {
};</pre>

<!-- ======================================================================================================= -->

    <h3 id="5.5"><span class="secno">5.5</span> WebGLFramebuffer</h3>

    <p>
        The <code>WebGLFramebuffer</code> interface represents an OpenGL Framebuffer Object. The
        underlying object is created as if by calling 
        <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glGenFramebuffers.xml">
            glGenFramebuffers
        </a>
        , bound as if by calling
        <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glBindFramebuffer.xml">
        glBindFramebuffer 
        </a>
        and destroyed as if by calling 
        <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glDeleteFramebuffers.xml">
        glDeleteFramebuffers.
        </a>
    </p>
    <pre class="idl">interface <dfn id="WebGLFramebuffer">WebGLFramebuffer</dfn> : WebGLObject {
};</pre>

<!-- ======================================================================================================= -->

    <h3 id="5.6"><span class="secno">5.6</span> WebGLProgram</h3>

    <p>
        The <code>WebGLProgram</code> interface represents an OpenGL Program Object. The
        underlying object is created as if by calling 
        <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glCreateProgram.xml">
            glCreateProgram
        </a>
        , used as if by calling
        <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glUseProgram.xml">
        glUseProgram 
        </a>
        and destroyed as if by calling 
        <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glDeleteProgram.xml">
        glDeleteProgram.
        </a>
    </p>
    <pre class="idl">interface <dfn id="WebGLProgram">WebGLProgram</dfn> : WebGLObject {
};</pre>

<!-- ======================================================================================================= -->

    <h3 id="5.7"><span class="secno">5.7</span> WebGLRenderbuffer</h3>

    <p>
        The <code>WebGLRenderbuffer</code> interface represents an OpenGL Renderbuffer Object. The
        underlying object is created as if by calling 
        <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glGenRenderbuffers.xml">
            glGenRenderbuffers
        </a>
        , bound as if by calling
        <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glBindRenderbuffer.xml">
        glBindRenderbuffer 
        </a>
        and destroyed as if by calling 
        <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glDeleteRenderbuffers.xml">
        glDeleteRenderbuffers.
        </a>
    </p>
    <pre class="idl">interface <dfn id="WebGLRenderbuffer">WebGLRenderbuffer</dfn> : WebGLObject {
};</pre>

<!-- ======================================================================================================= -->

    <h3 id="5.8"><span class="secno">5.8</span> WebGLShader</h3>

    <p>
        The <code>WebGLShader</code> interface represents an OpenGL Shader Object. The
        underlying object is created as if by calling 
        <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glCreateShader.xml">
            glCreateShader
        </a>
        , attached to a Program as if by calling
        <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glAttachShader.xml">
        glAttachShader 
        </a>
        and destroyed as if by calling 
        <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glDeleteShader.xml">
        glDeleteShader.
        </a>
    </p>
    <pre class="idl">interface <dfn id="WebGLShader">WebGLShader</dfn> : WebGLObject {
};</pre>

<!-- ======================================================================================================= -->

    <h3 id="5.9"><span class="secno">5.9</span> WebGLTexture</h3>

    <p>
        The <code>WebGLTexture</code> interface represents an OpenGL Texture Object. The
        underlying object is created as if by calling 
        <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glGenTextures.xml">
            glGenTextures
        </a>
        , bound as if by calling
        <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glBindTexture.xml">
        glBindTexture 
        </a>
        and destroyed as if by calling 
        <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glDeleteTextures.xml">
        glDeleteTextures.
        </a>
    </p>
    <pre class="idl">interface <dfn id="WebGLTexture">WebGLTexture</dfn> : WebGLObject {
};</pre>

<!-- ======================================================================================================= -->

    <h3 id="5.10"><span class="secno">5.10</span> WebGLUniformLocation</h3>

    <p>
        The <code>WebGLUniformLocation</code> interface represents the location of a uniform variable 
        in a shader program.
    </p>
    <pre class="idl">interface <dfn id="WebGLUniformLocation">WebGLUniformLocation</dfn> {
};</pre>

<!-- ======================================================================================================= -->

    <h3 id="5.11"><span class="secno">5.11</span> WebGLActiveInfo</h3>

    <p>
        The <code>WebGLActiveInfo</code> interface represents the information returned 
        from the getActiveAttrib and getActiveUniform calls.
    </p>
    <pre class="idl">interface <dfn id="WebGLActiveInfo">WebGLActiveInfo</dfn> {
    readonly attribute GLint size;
    readonly attribute GLenum type;
    readonly attribute DOMString name;
};</pre>

    <h4 id="5.11.1"><span class="secno">5.11.1</span> Attributes</h4>

    <p>
        The following attributes are available:
    </p>

    <dl class="methods">
        <dt>
            <code class="attribute-name">
                <a id="DOM-WebGLActiveInfo-size">
                    size
                </a>
            </code> 
            of type <code>GLint</code>
        </dt><dd>
            The size of the requested variable.
        </dd><dt>
            <code class="attribute-name">
                <a id="DOM-WebGLActiveInfo-type">
                    type
                </a>
            </code> 
            of type <code>GLenum</code>
        </dt><dd>
            The data type of the requested variable.
        </dd><dt>
            <code class="attribute-name">
                <a id="DOM-WebGLActiveInfo-name">
                    name
                </a>
            </code> 
            of type <code>DOMString</code>
        </dt><dd>
            The name of the requested variable.
    </dd></dl>

<!-- ======================================================================================================= -->

    <h3 id="5.12"><span class="secno">5.12</span> <a name="ARRAYBUFFER">ArrayBuffer</a> and <a name="TYPEDARRAY">Typed Arrays</a></h3>

    <p>
        Vertex, index, texture, and other data is transferred to the WebGL implementation using
        the <a href="https://cvs.khronos.org/svn/repos/registry/trunk/public/webgl/doc/spec/TypedArray-spec.html#ARRAYBUFFER">ArrayBuffer</a>
        and <a href="https://cvs.khronos.org/svn/repos/registry/trunk/public/webgl/doc/spec/TypedArray-spec.html#TYPEDARRAYS">views</a> defined in
        the <a href="https://cvs.khronos.org/svn/repos/registry/trunk/public/webgl/doc/spec/TypedArray-spec.html">Typed Array</a>
        specification <a href="#refsTYPEDARRAYS">[TYPEDARRAYS]</a>. All of the typed array views
        except <tt>Float64Array</tt> may be used in conjunction with WebGL; OpenGL ES 2.0, and
        therefore WebGL, does not support double-precision floating-point data.
    </p>
    <p>
        Typed Arrays support the creation of interleaved, heterogeneous vertex data; uploading of
        distinct blocks of data into a large vertex buffer object; and most other use cases required
        by OpenGL programs.
    </p>

    <div class="example">
    Here is an ECMAScript example showing access to the same ArrayBuffer using different types of
    typed arrays. In this case the buffer contains a floating point vertex position (x, y, z)
    followed by a color as 4 unsigned bytes (r, g, b, a).

    <pre>var numVertices = 100; // for example

// Compute the size needed for the buffer, in bytes and floats
var vertexSize = 3 * Float32Array.BYTES_PER_ELEMENT +
     4 * Uint8Array.BYTES_PER_ELEMENT;
var vertexSizeInFloats = vertexSize / Float32Array.BYTES_PER_ELEMENT;

// Allocate the buffer
var buf = new ArrayBuffer(numVertices * vertexSize);

// Map this buffer to a Float32Array to access the positions
var positionArray = new Float32Array(buf);

// Map the same buffer to a Uint8Array to access the color
var colorArray = new Uint8Array(buf);

// Set up the initial offset of the vertices and colors within the buffer
var positionIdx = 0;
var colorIdx = 3 * Float32Array.BYTES_PER_ELEMENT;

// Initialize the buffer
for (var i = 0; i &lt; numVertices; i++) {
    positionArray[positionIdx] = ...;
    positionArray[positionIdx + 1] = ...;
    positionArray[positionIdx + 2] = ...;
    colorArray[colorIdx] = ...;
    colorArray[colorIdx + 1] = ...;
    colorArray[colorIdx + 2] = ...;
    colorArray[colorIdx + 3] = ...;
    positionIdx += vertexSizeInFloats;
    colorIdx += vertexSize;
}
    </pre>
    </div>

<!-- ======================================================================================================= -->

    <h3 id="5.13"><span class="secno">5.13</span> The WebGL context</h3>

    <p>
        The <code>WebGLRenderingContext</code> represents the API allowing
        OpenGL ES 2.0 style rendering into the canvas element.
    </p>
    <pre class="idl">interface <dfn id="WebGLRenderingContext">WebGLRenderingContext</dfn> {

    /* ClearBufferMask */
    const GLenum DEPTH_BUFFER_BIT               = 0x00000100;
    const GLenum STENCIL_BUFFER_BIT             = 0x00000400;
    const GLenum COLOR_BUFFER_BIT               = 0x00004000;
    
    /* BeginMode */
    const GLenum POINTS                         = 0x0000;
    const GLenum LINES                          = 0x0001;
    const GLenum LINE_LOOP                      = 0x0002;
    const GLenum LINE_STRIP                     = 0x0003;
    const GLenum TRIANGLES                      = 0x0004;
    const GLenum TRIANGLE_STRIP                 = 0x0005;
    const GLenum TRIANGLE_FAN                   = 0x0006;
    
    /* AlphaFunction (not supported in ES20) */
    /*      NEVER */
    /*      LESS */
    /*      EQUAL */
    /*      LEQUAL */
    /*      GREATER */
    /*      NOTEQUAL */
    /*      GEQUAL */
    /*      ALWAYS */
    
    /* BlendingFactorDest */
    const GLenum ZERO                           = 0;
    const GLenum ONE                            = 1;
    const GLenum SRC_COLOR                      = 0x0300;
    const GLenum ONE_MINUS_SRC_COLOR            = 0x0301;
    const GLenum SRC_ALPHA                      = 0x0302;
    const GLenum ONE_MINUS_SRC_ALPHA            = 0x0303;
    const GLenum DST_ALPHA                      = 0x0304;
    const GLenum ONE_MINUS_DST_ALPHA            = 0x0305;
    
    /* BlendingFactorSrc */
    /*      ZERO */
    /*      ONE */
    const GLenum DST_COLOR                      = 0x0306;
    const GLenum ONE_MINUS_DST_COLOR            = 0x0307;
    const GLenum SRC_ALPHA_SATURATE             = 0x0308;
    /*      SRC_ALPHA */
    /*      ONE_MINUS_SRC_ALPHA */
    /*      DST_ALPHA */
    /*      ONE_MINUS_DST_ALPHA */
    
    /* BlendEquationSeparate */
    const GLenum FUNC_ADD                       = 0x8006;
    const GLenum BLEND_EQUATION                 = 0x8009;
    const GLenum BLEND_EQUATION_RGB             = 0x8009;   /* same as BLEND_EQUATION */
    const GLenum BLEND_EQUATION_ALPHA           = 0x883D;
    
    /* BlendSubtract */
    const GLenum FUNC_SUBTRACT                  = 0x800A;
    const GLenum FUNC_REVERSE_SUBTRACT          = 0x800B;
    
    /* Separate Blend Functions */
    const GLenum BLEND_DST_RGB                  = 0x80C8;
    const GLenum BLEND_SRC_RGB                  = 0x80C9;
    const GLenum BLEND_DST_ALPHA                = 0x80CA;
    const GLenum BLEND_SRC_ALPHA                = 0x80CB;
    const GLenum CONSTANT_COLOR                 = 0x8001;
    const GLenum ONE_MINUS_CONSTANT_COLOR       = 0x8002;
    const GLenum CONSTANT_ALPHA                 = 0x8003;
    const GLenum ONE_MINUS_CONSTANT_ALPHA       = 0x8004;
    const GLenum BLEND_COLOR                    = 0x8005;
    
    /* Buffer Objects */
    const GLenum ARRAY_BUFFER                   = 0x8892;
    const GLenum ELEMENT_ARRAY_BUFFER           = 0x8893;
    const GLenum ARRAY_BUFFER_BINDING           = 0x8894;
    const GLenum ELEMENT_ARRAY_BUFFER_BINDING   = 0x8895;
    
    const GLenum STREAM_DRAW                    = 0x88E0;
    const GLenum STATIC_DRAW                    = 0x88E4;
    const GLenum DYNAMIC_DRAW                   = 0x88E8;
    
    const GLenum BUFFER_SIZE                    = 0x8764;
    const GLenum BUFFER_USAGE                   = 0x8765;
    
    const GLenum CURRENT_VERTEX_ATTRIB          = 0x8626;
    
    /* CullFaceMode */
    const GLenum FRONT                          = 0x0404;
    const GLenum BACK                           = 0x0405;
    const GLenum FRONT_AND_BACK                 = 0x0408;
    
    /* DepthFunction */
    /*      NEVER */
    /*      LESS */
    /*      EQUAL */
    /*      LEQUAL */
    /*      GREATER */
    /*      NOTEQUAL */
    /*      GEQUAL */
    /*      ALWAYS */
    
    /* EnableCap */
    /* TEXTURE_2D */
    const GLenum CULL_FACE                      = 0x0B44;
    const GLenum BLEND                          = 0x0BE2;
    const GLenum DITHER                         = 0x0BD0;
    const GLenum STENCIL_TEST                   = 0x0B90;
    const GLenum DEPTH_TEST                     = 0x0B71;
    const GLenum SCISSOR_TEST                   = 0x0C11;
    const GLenum POLYGON_OFFSET_FILL            = 0x8037;
    const GLenum SAMPLE_ALPHA_TO_COVERAGE       = 0x809E;
    const GLenum SAMPLE_COVERAGE                = 0x80A0;
    
    /* ErrorCode */
    const GLenum NO_ERROR                       = 0;
    const GLenum INVALID_ENUM                   = 0x0500;
    const GLenum INVALID_VALUE                  = 0x0501;
    const GLenum INVALID_OPERATION              = 0x0502;
    const GLenum OUT_OF_MEMORY                  = 0x0505;
    
    /* FrontFaceDirection */
    const GLenum CW                             = 0x0900;
    const GLenum CCW                            = 0x0901;
    
    /* GetPName */
    const GLenum LINE_WIDTH                     = 0x0B21;
    const GLenum ALIASED_POINT_SIZE_RANGE       = 0x846D;
    const GLenum ALIASED_LINE_WIDTH_RANGE       = 0x846E;
    const GLenum CULL_FACE_MODE                 = 0x0B45;
    const GLenum FRONT_FACE                     = 0x0B46;
    const GLenum DEPTH_RANGE                    = 0x0B70;
    const GLenum DEPTH_WRITEMASK                = 0x0B72;
    const GLenum DEPTH_CLEAR_VALUE              = 0x0B73;
    const GLenum DEPTH_FUNC                     = 0x0B74;
    const GLenum STENCIL_CLEAR_VALUE            = 0x0B91;
    const GLenum STENCIL_FUNC                   = 0x0B92;
    const GLenum STENCIL_FAIL                   = 0x0B94;
    const GLenum STENCIL_PASS_DEPTH_FAIL        = 0x0B95;
    const GLenum STENCIL_PASS_DEPTH_PASS        = 0x0B96;
    const GLenum STENCIL_REF                    = 0x0B97;
    const GLenum STENCIL_VALUE_MASK             = 0x0B93;
    const GLenum STENCIL_WRITEMASK              = 0x0B98;
    const GLenum STENCIL_BACK_FUNC              = 0x8800;
    const GLenum STENCIL_BACK_FAIL              = 0x8801;
    const GLenum STENCIL_BACK_PASS_DEPTH_FAIL   = 0x8802;
    const GLenum STENCIL_BACK_PASS_DEPTH_PASS   = 0x8803;
    const GLenum STENCIL_BACK_REF               = 0x8CA3;
    const GLenum STENCIL_BACK_VALUE_MASK        = 0x8CA4;
    const GLenum STENCIL_BACK_WRITEMASK         = 0x8CA5;
    const GLenum VIEWPORT                       = 0x0BA2;
    const GLenum SCISSOR_BOX                    = 0x0C10;
    /*      SCISSOR_TEST */
    const GLenum COLOR_CLEAR_VALUE              = 0x0C22;
    const GLenum COLOR_WRITEMASK                = 0x0C23;
    const GLenum UNPACK_ALIGNMENT               = 0x0CF5;
    const GLenum PACK_ALIGNMENT                 = 0x0D05;
    const GLenum MAX_TEXTURE_SIZE               = 0x0D33;
    const GLenum MAX_VIEWPORT_DIMS              = 0x0D3A;
    const GLenum SUBPIXEL_BITS                  = 0x0D50;
    const GLenum RED_BITS                       = 0x0D52;
    const GLenum GREEN_BITS                     = 0x0D53;
    const GLenum BLUE_BITS                      = 0x0D54;
    const GLenum ALPHA_BITS                     = 0x0D55;
    const GLenum DEPTH_BITS                     = 0x0D56;
    const GLenum STENCIL_BITS                   = 0x0D57;
    const GLenum POLYGON_OFFSET_UNITS           = 0x2A00;
    /*      POLYGON_OFFSET_FILL */
    const GLenum POLYGON_OFFSET_FACTOR          = 0x8038;
    const GLenum TEXTURE_BINDING_2D             = 0x8069;
    const GLenum SAMPLE_BUFFERS                 = 0x80A8;
    const GLenum SAMPLES                        = 0x80A9;
    const GLenum SAMPLE_COVERAGE_VALUE          = 0x80AA;
    const GLenum SAMPLE_COVERAGE_INVERT         = 0x80AB;
    
    /* GetTextureParameter */
    /*      TEXTURE_MAG_FILTER */
    /*      TEXTURE_MIN_FILTER */
    /*      TEXTURE_WRAP_S */
    /*      TEXTURE_WRAP_T */
    
    const GLenum NUM_COMPRESSED_TEXTURE_FORMATS = 0x86A2;
    const GLenum COMPRESSED_TEXTURE_FORMATS     = 0x86A3;
    
    /* HintMode */
    const GLenum DONT_CARE                      = 0x1100;
    const GLenum FASTEST                        = 0x1101;
    const GLenum NICEST                         = 0x1102;
    
    /* HintTarget */
    const GLenum GENERATE_MIPMAP_HINT            = 0x8192;
    
    /* DataType */
    const GLenum BYTE                           = 0x1400;
    const GLenum UNSIGNED_BYTE                  = 0x1401;
    const GLenum SHORT                          = 0x1402;
    const GLenum UNSIGNED_SHORT                 = 0x1403;
    const GLenum INT                            = 0x1404;
    const GLenum UNSIGNED_INT                   = 0x1405;
    const GLenum FLOAT                          = 0x1406;
    
    /* PixelFormat */
    const GLenum DEPTH_COMPONENT                = 0x1902;
    const GLenum ALPHA                          = 0x1906;
    const GLenum RGB                            = 0x1907;
    const GLenum RGBA                           = 0x1908;
    const GLenum LUMINANCE                      = 0x1909;
    const GLenum LUMINANCE_ALPHA                = 0x190A;
    
    /* PixelType */
    /*      UNSIGNED_BYTE */
    const GLenum UNSIGNED_SHORT_4_4_4_4         = 0x8033;
    const GLenum UNSIGNED_SHORT_5_5_5_1         = 0x8034;
    const GLenum UNSIGNED_SHORT_5_6_5           = 0x8363;
    
    /* Shaders */
    const GLenum FRAGMENT_SHADER                  = 0x8B30;
    const GLenum VERTEX_SHADER                    = 0x8B31;
    const GLenum MAX_VERTEX_ATTRIBS               = 0x8869;
    const GLenum MAX_VERTEX_UNIFORM_VECTORS       = 0x8DFB;
    const GLenum MAX_VARYING_VECTORS              = 0x8DFC;
    const GLenum MAX_COMBINED_TEXTURE_IMAGE_UNITS = 0x8B4D;
    const GLenum MAX_VERTEX_TEXTURE_IMAGE_UNITS   = 0x8B4C;
    const GLenum MAX_TEXTURE_IMAGE_UNITS          = 0x8872;
    const GLenum MAX_FRAGMENT_UNIFORM_VECTORS     = 0x8DFD;
    const GLenum SHADER_TYPE                      = 0x8B4F;
    const GLenum DELETE_STATUS                    = 0x8B80;
    const GLenum LINK_STATUS                      = 0x8B82;
    const GLenum VALIDATE_STATUS                  = 0x8B83;
    const GLenum ATTACHED_SHADERS                 = 0x8B85;
    const GLenum ACTIVE_UNIFORMS                  = 0x8B86;
    const GLenum ACTIVE_UNIFORM_MAX_LENGTH        = 0x8B87;
    const GLenum ACTIVE_ATTRIBUTES                = 0x8B89;
    const GLenum ACTIVE_ATTRIBUTE_MAX_LENGTH      = 0x8B8A;
    const GLenum SHADING_LANGUAGE_VERSION         = 0x8B8C;
    const GLenum CURRENT_PROGRAM                  = 0x8B8D;
    
    /* StencilFunction */
    const GLenum NEVER                          = 0x0200;
    const GLenum LESS                           = 0x0201;
    const GLenum EQUAL                          = 0x0202;
    const GLenum LEQUAL                         = 0x0203;
    const GLenum GREATER                        = 0x0204;
    const GLenum NOTEQUAL                       = 0x0205;
    const GLenum GEQUAL                         = 0x0206;
    const GLenum ALWAYS                         = 0x0207;
    
    /* StencilOp */
    /*      ZERO */
    const GLenum KEEP                           = 0x1E00;
    const GLenum REPLACE                        = 0x1E01;
    const GLenum INCR                           = 0x1E02;
    const GLenum DECR                           = 0x1E03;
    const GLenum INVERT                         = 0x150A;
    const GLenum INCR_WRAP                      = 0x8507;
    const GLenum DECR_WRAP                      = 0x8508;
    
    /* StringName */
    const GLenum VENDOR                         = 0x1F00;
    const GLenum RENDERER                       = 0x1F01;
    const GLenum VERSION                        = 0x1F02;
    
    /* TextureMagFilter */
    const GLenum NEAREST                        = 0x2600;
    const GLenum LINEAR                         = 0x2601;
    
    /* TextureMinFilter */
    /*      NEAREST */
    /*      LINEAR */
    const GLenum NEAREST_MIPMAP_NEAREST         = 0x2700;
    const GLenum LINEAR_MIPMAP_NEAREST          = 0x2701;
    const GLenum NEAREST_MIPMAP_LINEAR          = 0x2702;
    const GLenum LINEAR_MIPMAP_LINEAR           = 0x2703;
    
    /* TextureParameterName */
    const GLenum TEXTURE_MAG_FILTER             = 0x2800;
    const GLenum TEXTURE_MIN_FILTER             = 0x2801;
    const GLenum TEXTURE_WRAP_S                 = 0x2802;
    const GLenum TEXTURE_WRAP_T                 = 0x2803;
    
    /* TextureTarget */
    const GLenum TEXTURE_2D                     = 0x0DE1;
    const GLenum TEXTURE                        = 0x1702;
    
    const GLenum TEXTURE_CUBE_MAP               = 0x8513;
    const GLenum TEXTURE_BINDING_CUBE_MAP       = 0x8514;
    const GLenum TEXTURE_CUBE_MAP_POSITIVE_X    = 0x8515;
    const GLenum TEXTURE_CUBE_MAP_NEGATIVE_X    = 0x8516;
    const GLenum TEXTURE_CUBE_MAP_POSITIVE_Y    = 0x8517;
    const GLenum TEXTURE_CUBE_MAP_NEGATIVE_Y    = 0x8518;
    const GLenum TEXTURE_CUBE_MAP_POSITIVE_Z    = 0x8519;
    const GLenum TEXTURE_CUBE_MAP_NEGATIVE_Z    = 0x851A;
    const GLenum MAX_CUBE_MAP_TEXTURE_SIZE      = 0x851C;
    
    /* TextureUnit */
    const GLenum TEXTURE0                       = 0x84C0;
    const GLenum TEXTURE1                       = 0x84C1;
    const GLenum TEXTURE2                       = 0x84C2;
    const GLenum TEXTURE3                       = 0x84C3;
    const GLenum TEXTURE4                       = 0x84C4;
    const GLenum TEXTURE5                       = 0x84C5;
    const GLenum TEXTURE6                       = 0x84C6;
    const GLenum TEXTURE7                       = 0x84C7;
    const GLenum TEXTURE8                       = 0x84C8;
    const GLenum TEXTURE9                       = 0x84C9;
    const GLenum TEXTURE10                      = 0x84CA;
    const GLenum TEXTURE11                      = 0x84CB;
    const GLenum TEXTURE12                      = 0x84CC;
    const GLenum TEXTURE13                      = 0x84CD;
    const GLenum TEXTURE14                      = 0x84CE;
    const GLenum TEXTURE15                      = 0x84CF;
    const GLenum TEXTURE16                      = 0x84D0;
    const GLenum TEXTURE17                      = 0x84D1;
    const GLenum TEXTURE18                      = 0x84D2;
    const GLenum TEXTURE19                      = 0x84D3;
    const GLenum TEXTURE20                      = 0x84D4;
    const GLenum TEXTURE21                      = 0x84D5;
    const GLenum TEXTURE22                      = 0x84D6;
    const GLenum TEXTURE23                      = 0x84D7;
    const GLenum TEXTURE24                      = 0x84D8;
    const GLenum TEXTURE25                      = 0x84D9;
    const GLenum TEXTURE26                      = 0x84DA;
    const GLenum TEXTURE27                      = 0x84DB;
    const GLenum TEXTURE28                      = 0x84DC;
    const GLenum TEXTURE29                      = 0x84DD;
    const GLenum TEXTURE30                      = 0x84DE;
    const GLenum TEXTURE31                      = 0x84DF;
    const GLenum ACTIVE_TEXTURE                 = 0x84E0;
    
    /* TextureWrapMode */
    const GLenum REPEAT                         = 0x2901;
    const GLenum CLAMP_TO_EDGE                  = 0x812F;
    const GLenum MIRRORED_REPEAT                = 0x8370;
    
    /* Uniform Types */
    const GLenum FLOAT_VEC2                     = 0x8B50;
    const GLenum FLOAT_VEC3                     = 0x8B51;
    const GLenum FLOAT_VEC4                     = 0x8B52;
    const GLenum INT_VEC2                       = 0x8B53;
    const GLenum INT_VEC3                       = 0x8B54;
    const GLenum INT_VEC4                       = 0x8B55;
    const GLenum BOOL                           = 0x8B56;
    const GLenum BOOL_VEC2                      = 0x8B57;
    const GLenum BOOL_VEC3                      = 0x8B58;
    const GLenum BOOL_VEC4                      = 0x8B59;
    const GLenum FLOAT_MAT2                     = 0x8B5A;
    const GLenum FLOAT_MAT3                     = 0x8B5B;
    const GLenum FLOAT_MAT4                     = 0x8B5C;
    const GLenum SAMPLER_2D                     = 0x8B5E;
    const GLenum SAMPLER_CUBE                   = 0x8B60;
    
    /* Vertex Arrays */
    const GLenum VERTEX_ATTRIB_ARRAY_ENABLED        = 0x8622;
    const GLenum VERTEX_ATTRIB_ARRAY_SIZE           = 0x8623;
    const GLenum VERTEX_ATTRIB_ARRAY_STRIDE         = 0x8624;
    const GLenum VERTEX_ATTRIB_ARRAY_TYPE           = 0x8625;
    const GLenum VERTEX_ATTRIB_ARRAY_NORMALIZED     = 0x886A;
    const GLenum VERTEX_ATTRIB_ARRAY_POINTER        = 0x8645;
    const GLenum VERTEX_ATTRIB_ARRAY_BUFFER_BINDING = 0x889F;
    
    /* Read Format */
    const GLenum IMPLEMENTATION_COLOR_READ_TYPE   = 0x8B9A;
    const GLenum IMPLEMENTATION_COLOR_READ_FORMAT = 0x8B9B;
    
    /* Shader Source */
    const GLenum COMPILE_STATUS                 = 0x8B81;
    const GLenum INFO_LOG_LENGTH                = 0x8B84;
    const GLenum SHADER_SOURCE_LENGTH           = 0x8B88;
    
    /* Shader Precision-Specified Types */
    const GLenum LOW_FLOAT                      = 0x8DF0;
    const GLenum MEDIUM_FLOAT                   = 0x8DF1;
    const GLenum HIGH_FLOAT                     = 0x8DF2;
    const GLenum LOW_INT                        = 0x8DF3;
    const GLenum MEDIUM_INT                     = 0x8DF4;
    const GLenum HIGH_INT                       = 0x8DF5;
    
    /* Framebuffer Object. */
    const GLenum FRAMEBUFFER                    = 0x8D40;
    const GLenum RENDERBUFFER                   = 0x8D41;
    
    const GLenum RGBA4                          = 0x8056;
    const GLenum RGB5_A1                        = 0x8057;
    const GLenum RGB565                         = 0x8D62;
    const GLenum DEPTH_COMPONENT16              = 0x81A5;
    const GLenum STENCIL_INDEX                  = 0x1901;
    const GLenum STENCIL_INDEX8                 = 0x8D48;
    const GLenum DEPTH_STENCIL                  = 0x84F9;
    
    const GLenum RENDERBUFFER_WIDTH             = 0x8D42;
    const GLenum RENDERBUFFER_HEIGHT            = 0x8D43;
    const GLenum RENDERBUFFER_INTERNAL_FORMAT   = 0x8D44;
    const GLenum RENDERBUFFER_RED_SIZE          = 0x8D50;
    const GLenum RENDERBUFFER_GREEN_SIZE        = 0x8D51;
    const GLenum RENDERBUFFER_BLUE_SIZE         = 0x8D52;
    const GLenum RENDERBUFFER_ALPHA_SIZE        = 0x8D53;
    const GLenum RENDERBUFFER_DEPTH_SIZE        = 0x8D54;
    const GLenum RENDERBUFFER_STENCIL_SIZE      = 0x8D55;
    
    const GLenum FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE           = 0x8CD0;
    const GLenum FRAMEBUFFER_ATTACHMENT_OBJECT_NAME           = 0x8CD1;
    const GLenum FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL         = 0x8CD2;
    const GLenum FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE = 0x8CD3;
    
    const GLenum COLOR_ATTACHMENT0              = 0x8CE0;
    const GLenum DEPTH_ATTACHMENT               = 0x8D00;
    const GLenum STENCIL_ATTACHMENT             = 0x8D20;
    const GLenum DEPTH_STENCIL_ATTACHMENT       = 0x821A;
    
    const GLenum NONE                           = 0;
    
    const GLenum FRAMEBUFFER_COMPLETE                      = 0x8CD5;
    const GLenum FRAMEBUFFER_INCOMPLETE_ATTACHMENT         = 0x8CD6;
    const GLenum FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT = 0x8CD7;
    const GLenum FRAMEBUFFER_INCOMPLETE_DIMENSIONS         = 0x8CD9;
    const GLenum FRAMEBUFFER_UNSUPPORTED                   = 0x8CDD;
    
    const GLenum FRAMEBUFFER_BINDING            = 0x8CA6;
    const GLenum RENDERBUFFER_BINDING           = 0x8CA7;
    const GLenum MAX_RENDERBUFFER_SIZE          = 0x84E8;
    
    const GLenum INVALID_FRAMEBUFFER_OPERATION  = 0x0506;
    
    /* WebGL-specific enums */
    const GLenum UNPACK_FLIP_Y_WEBGL            = 0x9240;
    const GLenum UNPACK_PREMULTIPLY_ALPHA_WEBGL = 0x9241;
    const GLenum CONTEXT_LOST_WEBGL             = 0x9242;

    readonly attribute HTMLCanvasElement canvas;

    WebGLContextAttributes getContextAttributes();

    boolean isContextLost();
    
    DOMString[ ] getSupportedExtensions();
    object getExtension(DOMString name);

    void activeTexture(GLenum texture);
    void attachShader(WebGLProgram program, WebGLShader shader);
    void bindAttribLocation(WebGLProgram program, GLuint index, DOMString name);
    void bindBuffer(GLenum target, WebGLBuffer buffer);
    void bindFramebuffer(GLenum target, WebGLFramebuffer framebuffer);
    void bindRenderbuffer(GLenum target, WebGLRenderbuffer renderbuffer);
    void bindTexture(GLenum target, WebGLTexture texture);
    void blendColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);
    void blendEquation(GLenum mode);
    void blendEquationSeparate(GLenum modeRGB, GLenum modeAlpha);
    void blendFunc(GLenum sfactor, GLenum dfactor);
    void blendFuncSeparate(GLenum srcRGB, GLenum dstRGB, 
                           GLenum srcAlpha, GLenum dstAlpha);

    void bufferData(GLenum target, GLsizei size, GLenum usage);
    void bufferData(GLenum target, ArrayBufferView data, GLenum usage);
    void bufferData(GLenum target, ArrayBuffer data, GLenum usage);
    void bufferSubData(GLenum target, GLsizeiptr offset, ArrayBufferView data);
    void bufferSubData(GLenum target, GLsizeiptr offset, ArrayBuffer data);

    GLenum checkFramebufferStatus(GLenum target);
    void clear(GLbitfield mask);
    void clearColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);
    void clearDepth(GLclampf depth);
    void clearStencil(GLint s);
    void colorMask(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha);
    void compileShader(WebGLShader shader);

    void copyTexImage2D(GLenum target, GLint level, GLenum internalformat, 
                        GLint x, GLint y, GLsizei width, GLsizei height, 
                        GLint border);
    void copyTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, 
                           GLint x, GLint y, GLsizei width, GLsizei height);

    WebGLBuffer createBuffer();
    WebGLFramebuffer createFramebuffer();
    WebGLProgram createProgram();
    WebGLRenderbuffer createRenderbuffer();
    WebGLShader createShader(GLenum type);
    WebGLTexture createTexture();

    void cullFace(GLenum mode);

    void deleteBuffer(WebGLBuffer buffer);
    void deleteFramebuffer(WebGLFramebuffer framebuffer);
    void deleteProgram(WebGLProgram program);
    void deleteRenderbuffer(WebGLRenderbuffer renderbuffer);
    void deleteShader(WebGLShader shader);
    void deleteTexture(WebGLTexture texture);

    void depthFunc(GLenum func);
    void depthMask(GLboolean flag);
    void depthRange(GLclampf zNear, GLclampf zFar);
    void detachShader(WebGLProgram program, WebGLShader shader);
    void disable(GLenum cap);
    void disableVertexAttribArray(GLuint index);
    void drawArrays(GLenum mode, GLint first, GLsizei count);
    void drawElements(GLenum mode, GLsizei count, GLenum type, GLsizeiptr offset);

    void enable(GLenum cap);
    void enableVertexAttribArray(GLuint index);
    void finish();
    void flush();
    void framebufferRenderbuffer(GLenum target, GLenum attachment, 
                                 GLenum renderbuffertarget, 
                                 WebGLRenderbuffer renderbuffer);
    void framebufferTexture2D(GLenum target, GLenum attachment, GLenum textarget, 
                              WebGLTexture texture, GLint level);
    void frontFace(GLenum mode);

    void generateMipmap(GLenum target);

    WebGLActiveInfo getActiveAttrib(WebGLProgram program, GLuint index);
    WebGLActiveInfo getActiveUniform(WebGLProgram program, GLuint index);
    WebGLShader[ ] getAttachedShaders(WebGLProgram program);

    GLint getAttribLocation(WebGLProgram program, DOMString name);

    any getParameter(GLenum pname);
    any getBufferParameter(GLenum target, GLenum pname);

    GLenum getError();

    any getFramebufferAttachmentParameter(GLenum target, GLenum attachment, 
                                          GLenum pname);
    any getProgramParameter(WebGLProgram program, GLenum pname);
    DOMString getProgramInfoLog(WebGLProgram program);
    any getRenderbufferParameter(GLenum target, GLenum pname);
    any getShaderParameter(WebGLShader shader, GLenum pname);
    DOMString getShaderInfoLog(WebGLShader shader);

    DOMString getShaderSource(WebGLShader shader);

    any getTexParameter(GLenum target, GLenum pname);

    any getUniform(WebGLProgram program, WebGLUniformLocation location);

    WebGLUniformLocation getUniformLocation(WebGLProgram program, DOMString name);

    any getVertexAttrib(GLuint index, GLenum pname);

    GLsizeiptr getVertexAttribOffset(GLuint index, GLenum pname);

    void hint(GLenum target, GLenum mode);
    GLboolean isBuffer(WebGLBuffer buffer);
    GLboolean isEnabled(GLenum cap);
    GLboolean isFramebuffer(WebGLFramebuffer framebuffer);
    GLboolean isProgram(WebGLProgram program);
    GLboolean isRenderbuffer(WebGLRenderbuffer renderbuffer);
    GLboolean isShader(WebGLShader shader);
    GLboolean isTexture(WebGLTexture texture);
    void lineWidth(GLfloat width);
    void linkProgram(WebGLProgram program);
    void pixelStorei(GLenum pname, GLint param);
    void polygonOffset(GLfloat factor, GLfloat units);

    void readPixels(GLint x, GLint y, GLsizei width, GLsizei height, 
                    GLenum format, GLenum type, ArrayBufferView pixels);

    void renderbufferStorage(GLenum target, GLenum internalformat, 
                             GLsizei width, GLsizei height);
    void sampleCoverage(GLclampf value, GLboolean invert);
    void scissor(GLint x, GLint y, GLsizei width, GLsizei height);

    void shaderSource(WebGLShader shader, DOMString source);

    void stencilFunc(GLenum func, GLint ref, GLuint mask);
    void stencilFuncSeparate(GLenum face, GLenum func, GLint ref, GLuint mask);
    void stencilMask(GLuint mask);
    void stencilMaskSeparate(GLenum face, GLuint mask);
    void stencilOp(GLenum fail, GLenum zfail, GLenum zpass);
    void stencilOpSeparate(GLenum face, GLenum fail, GLenum zfail, GLenum zpass);

    void texImage2D(GLenum target, GLint level, GLenum internalformat, 
                    GLsizei width, GLsizei height, GLint border, GLenum format, 
                    GLenum type, ArrayBufferView pixels);
    void texImage2D(GLenum target, GLint level, GLenum internalformat,
                    GLenum format, GLenum type, ImageData pixels);
    void texImage2D(GLenum target, GLint level, GLenum internalformat,
                    GLenum format, GLenum type, HTMLImageElement image);
    void texImage2D(GLenum target, GLint level, GLenum internalformat,
                    GLenum format, GLenum type, HTMLCanvasElement canvas);
    void texImage2D(GLenum target, GLint level, GLenum internalformat,
                    GLenum format, GLenum type, HTMLVideoElement video);

    void texParameterf(GLenum target, GLenum pname, GLfloat param);
    void texParameteri(GLenum target, GLenum pname, GLint param);

    void texSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, 
                       GLsizei width, GLsizei height, 
                       GLenum format, GLenum type, ArrayBufferView pixels);
    void texSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, 
                       GLenum format, GLenum type, ImageData pixels);
    void texSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, 
                       GLenum format, GLenum type, HTMLImageElement image);
    void texSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, 
                       GLenum format, GLenum type, HTMLCanvasElement canvas);
    void texSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, 
                       GLenum format, GLenum type, HTMLVideoElement video);

    void uniform1f(WebGLUniformLocation location, GLfloat x);
    void uniform1fv(WebGLUniformLocation location, Float32Array v);
    void uniform1fv(WebGLUniformLocation location, sequence<float> v);
    void uniform1i(WebGLUniformLocation location, GLint x);
    void uniform1iv(WebGLUniformLocation location, Int32Array v);
    void uniform1iv(WebGLUniformLocation location, sequence<long> v);
    void uniform2f(WebGLUniformLocation location, GLfloat x, GLfloat y);
    void uniform2fv(WebGLUniformLocation location, Float32Array v);
    void uniform2fv(WebGLUniformLocation location, sequence<float> v);
    void uniform2i(WebGLUniformLocation location, GLint x, GLint y);
    void uniform2iv(WebGLUniformLocation location, Int32Array v);
    void uniform2iv(WebGLUniformLocation location, sequence<long> v);
    void uniform3f(WebGLUniformLocation location, GLfloat x, GLfloat y, GLfloat z);
    void uniform3fv(WebGLUniformLocation location, Float32Array v);
    void uniform3fv(WebGLUniformLocation location, sequence<float> v);
    void uniform3i(WebGLUniformLocation location, GLint x, GLint y, GLint z);
    void uniform3iv(WebGLUniformLocation location, Int32Array v);
    void uniform3iv(WebGLUniformLocation location, sequence<long> v);
    void uniform4f(WebGLUniformLocation location, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
    void uniform4fv(WebGLUniformLocation location, Float32Array v);
    void uniform4fv(WebGLUniformLocation location, sequence<float> v);
    void uniform4i(WebGLUniformLocation location, GLint x, GLint y, GLint z, GLint w);
    void uniform4iv(WebGLUniformLocation location, Int32Array v);
    void uniform4iv(WebGLUniformLocation location, sequence<long> v);

    void uniformMatrix2fv(WebGLUniformLocation location, GLboolean transpose, 
                          Float32Array value);
    void uniformMatrix2fv(WebGLUniformLocation location, GLboolean transpose, 
                          sequence<float> value);
    void uniformMatrix3fv(WebGLUniformLocation location, GLboolean transpose, 
                          Float32Array value);
    void uniformMatrix3fv(WebGLUniformLocation location, GLboolean transpose, 
                          sequence<float> value);
    void uniformMatrix4fv(WebGLUniformLocation location, GLboolean transpose, 
                          Float32Array value);
    void uniformMatrix4fv(WebGLUniformLocation location, GLboolean transpose, 
                          sequence<float> value);

    void useProgram(WebGLProgram program);
    void validateProgram(WebGLProgram program);

    void vertexAttrib1f(GLuint indx, GLfloat x);
    void vertexAttrib1fv(GLuint indx, Float32Array values);
    void vertexAttrib1fv(GLuint indx, sequence<float> values);
    void vertexAttrib2f(GLuint indx, GLfloat x, GLfloat y);
    void vertexAttrib2fv(GLuint indx, Float32Array values);
    void vertexAttrib2fv(GLuint indx, sequence<float> values);
    void vertexAttrib3f(GLuint indx, GLfloat x, GLfloat y, GLfloat z);
    void vertexAttrib3fv(GLuint indx, Float32Array values);
    void vertexAttrib3fv(GLuint indx, sequence<float> values);
    void vertexAttrib4f(GLuint indx, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
    void vertexAttrib4fv(GLuint indx, Float32Array values);
    void vertexAttrib4fv(GLuint indx, sequence<float> values);
    void vertexAttribPointer(GLuint indx, GLint size, GLenum type, 
                             GLboolean normalized, GLsizei stride, GLsizeiptr offset);

    void viewport(GLint x, GLint y, GLsizei width, GLsizei height);
};</float></float></float></float></float></float></float></long></float></long></float></long></float></long></float></pre>

<!-- ======================================================================================================= -->

    <h4 id="5.13.1"><span class="secno">5.13.1</span> Attributes</h4>

    <p>
        The following attributes are available:
    </p>

    <dl class="methods">
        <dt>
            <code class="attribute-name">
                <a id="DOM-WebGLRenderingContext-canvas">
                    canvas
                </a>
            </code> 
            of type <code>HTMLCanvasElement</code>
        </dt><dd>
            A reference to the canvas element which created this context.

    </dd></dl>

<!-- ======================================================================================================= -->

    <h4 id="5.13.2"><span class="secno">5.13.2</span> The <code>getContextAttributes</code> method</h4>

    <dl class="methods">
        <dt class="idl-code">WebGLContextAttributes getContextAttributes()
        </dt><dd>
            Returns the WebGLContextAttributes describing the current drawing buffer.
    </dd></dl>
     
<!-- ======================================================================================================= -->

    <h4 id="5.13.3"><span class="secno">5.13.3</span> Setting and getting state</h4>

    <p>
        OpenGL ES 2.0 maintains state values for use in rendering. All the calls in this
        group behave identically to their OpenGL counterparts unless otherwise noted.
    </p>
    
    <dl class="methods">
        <dt class="idl-code">void activeTexture(GLenum texture)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glActiveTexture.xml">
                (OpenGL ES 2.0 man page)
            </a>
        </dt><dt class="idl-code" void="" blendcolor(glclampf="" red,="" glclampf="" green,="" blue,="" alpha)="" <a="" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glBlendColor.xml">
                (OpenGL ES 2.0 man page)
            
        </dt><dt class="idl-code">void blendEquation(GLenum mode)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glBlendEquation.xml">
                (OpenGL ES 2.0 man page)
            </a>
        </dt><dt class="idl-code">void blendEquationSeparate(GLenum modeRGB, GLenum modeAlpha)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glBlendEquationSeparate.xml">
                (OpenGL ES 2.0 man page)
            </a>
        </dt><dt class="idl-code">void blendFunc(GLenum sfactor, GLenum dfactor)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glBlendFunc.xml">
                (OpenGL ES 2.0 man page)
            </a>
            </dt><dd>
                See <a href="#CONSTANT_COLOR_BLEND">Blending With Constant Color</a> for limitations imposed
                by WebGL.
        </dd><dt class="idl-code">void blendFuncSeparate(GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glBlendFuncSeparate.xml">
                (OpenGL ES 2.0 man page)
            </a>
            </dt><dd>
                See <a href="#CONSTANT_COLOR_BLEND">Blending With Constant Color</a> for limitations imposed
                by WebGL.
        </dd><dt class="idl-code">void clearColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glClearColor.xml">
                (OpenGL ES 2.0 man page)
            </a>
        </dt><dt class="idl-code">void clearDepth(GLclampf depth)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glClearDepthf.xml">
                (OpenGL ES 2.0 man page)
            </a>
            </dt><dd>
                <code>depth</code> value is clamped to the range 0 to 1.
        </dd><dt class="idl-code">void clearStencil(GLint s)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glClearStencil.xml">
                (OpenGL ES 2.0 man page)
            </a>
        </dt><dt class="idl-code">void colorMask(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glColorMask.xml">
                (OpenGL ES 2.0 man page)
            </a>
        </dt><dt class="idl-code">void cullFace(GLenum mode)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glCullFace.xml">
                (OpenGL ES 2.0 man page)
            </a>
        </dt><dt class="idl-code">void depthFunc(GLenum func)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glDepthFunc.xml">
                (OpenGL ES 2.0 man page)
            </a>
        </dt><dt class="idl-code">void depthMask(GLboolean flag)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glDepthMask.xml">
                (OpenGL ES 2.0 man page)
            </a>
        </dt><dt class="idl-code">void depthRange(GLclampf zNear, GLclampf zFar)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glDepthRangef.xml">
                (OpenGL ES 2.0 man page)
            </a>
            </dt><dd>
                <code>zNear</code> and <code>zFar</code> values are clamped to the range 0 to 1 and
                <code>zNear</code> must be less than or equal to <code>zFar</code>; see
                <a href="#VIEWPORT_DEPTH_RANGE">Viewport Depth Range</a>.
        </dd><dt class="idl-code">void disable(GLenum cap)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glDisable.xml">
                (OpenGL ES 2.0 man page)
            </a>
        </dt><dt class="idl-code">void enable(GLenum cap)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glEnable.xml">
                (OpenGL ES 2.0 man page)
            </a>
        </dt><dt class="idl-code">void frontFace(GLenum mode)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glFrontFace.xml">
                (OpenGL ES 2.0 man page)
            </a>
        </dt><dt class="idl-code">any getParameter(GLenum pname)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glGet.xml">
                (glGet OpenGL ES 2.0 man page)
            </a>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glGetString.xml">
                (glGetString OpenGL ES 2.0 man page)
            </a>
        </dt><dd>
            Return the value for the passed pname. The type returned is the natural type for the
            requested pname, as given in the following table:
            <table class="foo">
                <tbody><tr><th>pname</th><th>returned type</th></tr>
                <tr><td>ACTIVE_TEXTURE</td><td>unsigned long</td></tr>
                <tr><td>ALIASED_LINE_WIDTH_RANGE</td><td>Float32Array (with 2 elements)</td></tr>
                <tr><td>ALIASED_POINT_SIZE_RANGE</td><td>Float32Array (with 2 elements)</td></tr>
                <tr><td>ALPHA_BITS</td><td>long</td></tr>
                <tr><td>ARRAY_BUFFER_BINDING</td><td>WebGLBuffer</td></tr>
                <tr><td>BLEND</td><td>boolean</td></tr>
                <tr><td>BLEND_COLOR</td><td>Float32Array (with 4 values)</td></tr>
                <tr><td>BLEND_DST_ALPHA</td><td>unsigned long</td></tr>
                <tr><td>BLEND_DST_RGB</td><td>unsigned long</td></tr>
                <tr><td>BLEND_EQUATION_ALPHA</td><td>unsigned long</td></tr>
                <tr><td>BLEND_EQUATION_RGB</td><td>unsigned long</td></tr>
                <tr><td>BLEND_SRC_ALPHA</td><td>unsigned long</td></tr>
                <tr><td>BLEND_SRC_RGB</td><td>unsigned long</td></tr>
                <tr><td>BLUE_BITS</td><td>long</td></tr>
                <tr><td>COLOR_CLEAR_VALUE</td><td>Float32Array (with 4 values)</td></tr>
                <tr><td>COLOR_WRITEMASK</td><td>GLboolean[] (with 4 values)</td></tr>
                <tr><td>COMPRESSED_TEXTURE_FORMATS</td><td>null</td></tr>
                <tr><td>CULL_FACE</td><td>boolean</td></tr>
                <tr><td>CULL_FACE_MODE</td><td>unsigned long</td></tr>
                <tr><td>CURRENT_PROGRAM</td><td>WebGLProgram</td></tr>
                <tr><td>DEPTH_BITS</td><td>long</td></tr>
                <tr><td>DEPTH_CLEAR_VALUE</td><td>float</td></tr>
                <tr><td>DEPTH_FUNC</td><td>unsigned long</td></tr>
                <tr><td>DEPTH_RANGE</td><td>Float32Array (with 2 elements)</td></tr>
                <tr><td>DEPTH_TEST</td><td>boolean</td></tr>
                <tr><td>DEPTH_WRITEMASK</td><td>boolean</td></tr>
                <tr><td>DITHER</td><td>boolean</td></tr>
                <tr><td>ELEMENT_ARRAY_BUFFER_BINDING</td><td>WebGLBuffer</td></tr>
                <tr><td>FRAMEBUFFER_BINDING</td><td>WebGLFramebuffer</td></tr>
                <tr><td>FRONT_FACE</td><td>unsigned long</td></tr>
                <tr><td>GENERATE_MIPMAP_HINT</td><td>unsigned long</td></tr>
                <tr><td>GREEN_BITS</td><td>long</td></tr>
                <tr><td>IMPLEMENTATION_COLOR_READ_FORMAT</td><td>unsigned long</td></tr>
                <tr><td>IMPLEMENTATION_COLOR_READ_TYPE</td><td>unsigned long</td></tr>
                <tr><td>LINE_WIDTH</td><td>float</td></tr>
                <tr><td>MAX_COMBINED_TEXTURE_IMAGE_UNITS</td><td>long</td></tr>
                <tr><td>MAX_CUBE_MAP_TEXTURE_SIZE</td><td>long</td></tr>
                <tr><td>MAX_FRAGMENT_UNIFORM_VECTORS</td><td>long</td></tr>
                <tr><td>MAX_RENDERBUFFER_SIZE</td><td>long</td></tr>
                <tr><td>MAX_TEXTURE_IMAGE_UNITS</td><td>long</td></tr>
                <tr><td>MAX_TEXTURE_SIZE</td><td>long</td></tr>
                <tr><td>MAX_VARYING_VECTORS</td><td>long</td></tr>
                <tr><td>MAX_VERTEX_ATTRIBS</td><td>long</td></tr>
                <tr><td>MAX_VERTEX_TEXTURE_IMAGE_UNITS</td><td>long</td></tr>
                <tr><td>MAX_VERTEX_UNIFORM_VECTORS</td><td>long</td></tr>
                <tr><td>MAX_VIEWPORT_DIMS</td><td>Int32Array (with 2 elements)</td></tr>
                <tr><td>NUM_COMPRESSED_TEXTURE_FORMATS</td><td>long</td></tr>
                <tr><td>PACK_ALIGNMENT</td><td>long</td></tr>
                <tr><td>POLYGON_OFFSET_FACTOR</td><td>float</td></tr>
                <tr><td>POLYGON_OFFSET_FILL</td><td>boolean</td></tr>
                <tr><td>POLYGON_OFFSET_UNITS</td><td>float</td></tr>
                <tr><td>RED_BITS</td><td>long</td></tr>
                <tr><td>RENDERBUFFER_BINDING</td><td>WebGLRenderbuffer</td></tr>
                <tr><td>RENDERER</td><td>DOMString</td></tr>
                <tr><td>SAMPLE_BUFFERS</td><td>long</td></tr>
                <tr><td>SAMPLE_COVERAGE_INVERT</td><td>boolean</td></tr>
                <tr><td>SAMPLE_COVERAGE_VALUE</td><td>float</td></tr>
                <tr><td>SAMPLES</td><td>long</td></tr>
                <tr><td>SCISSOR_BOX</td><td>Int32Array (with 4 elements)</td></tr>
                <tr><td>SCISSOR_TEST</td><td>boolean</td></tr>
                <tr><td>SHADING_LANGUAGE_VERSION</td><td>DOMString</td></tr>
                <tr><td>STENCIL_BACK_FAIL</td><td>unsigned long</td></tr>
                <tr><td>STENCIL_BACK_FUNC</td><td>unsigned long</td></tr>
                <tr><td>STENCIL_BACK_PASS_DEPTH_FAIL</td><td>unsigned long</td></tr>
                <tr><td>STENCIL_BACK_PASS_DEPTH_PASS</td><td>unsigned long</td></tr>
                <tr><td>STENCIL_BACK_REF</td><td>long</td></tr>
                <tr><td>STENCIL_BACK_VALUE_MASK</td><td>unsigned long</td></tr>
                <tr><td>STENCIL_BACK_WRITEMASK</td><td>unsigned long</td></tr>
                <tr><td>STENCIL_BITS</td><td>long</td></tr>
                <tr><td>STENCIL_CLEAR_VALUE</td><td>long</td></tr>
                <tr><td>STENCIL_FAIL</td><td>unsigned long</td></tr>
                <tr><td>STENCIL_FUNC</td><td>unsigned long</td></tr>
                <tr><td>STENCIL_PASS_DEPTH_FAIL</td><td>unsigned long</td></tr>
                <tr><td>STENCIL_PASS_DEPTH_PASS</td><td>unsigned long</td></tr>
                <tr><td>STENCIL_REF</td><td>long</td></tr>
                <tr><td>STENCIL_TEST</td><td>boolean</td></tr>
                <tr><td>STENCIL_VALUE_MASK</td><td>unsigned long</td></tr>
                <tr><td>STENCIL_WRITEMASK</td><td>unsigned long</td></tr>
                <tr><td>SUBPIXEL_BITS</td><td>long</td></tr>
                <tr><td>TEXTURE_BINDING_2D</td><td>WebGLTexture</td></tr>
                <tr><td>TEXTURE_BINDING_CUBE_MAP</td><td>WebGLTexture</td></tr>
                <tr><td>UNPACK_ALIGNMENT</td><td>int</td></tr>
                <tr><td>UNPACK_FLIP_Y_WEBGL</td><td>boolean</td></tr>
                <tr><td>UNPACK_PREMULTIPLY_ALPHA_WEBGL</td><td>boolean</td></tr>
                <tr><td>VENDOR</td><td>DOMString</td></tr>
                <tr><td>VERSION</td><td>DOMString</td></tr>
                <tr><td>VIEWPORT</td><td>Int32Array (with 4 elements)</td></tr>
            </tbody></table><br>
            The following <em>pname</em> arguments return a string describing some aspect of the current WebGL implementation:
            <table>
              <tbody><tr><td>VERSION</td>
                  <td>Returns a version or release number of the form <code>WebGL&lt;space&gt;1.0&lt;space&gt;&lt;vendor-specific information&gt;</code>.</td></tr>
              <tr><td>SHADING_LANGUAGE_VERSION</td>
                  <td>Returns a version or release number of the form <code>WebGL&lt;space&gt;GLSL&lt;space&gt;ES&lt;space&gt;1.0&lt;space&gt;&lt;vendor-specific information&gt;</code>.</td></tr>
              <tr><td>VENDOR</td>
                  <td>Returns the company responsible for this WebGL implementation. This name does not change from release to release.</td></tr>
              <tr><td>RENDERER</td>
                  <td>Returns the name of the renderer. This name is 
typically specific to a particular configuration of a hardware platform.
 It does not change from release to release.</td></tr>
            </tbody></table><br>
            See <a href="#EXTENSION_QUERIES">Extension Queries</a> for information on querying the
            available extensions in the current WebGL implementation.
        </dd><dt class="idl-code">GLenum getError()
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glGetError.xml">
                (OpenGL ES 2.0 man page)
            </a>
            </dt><dd>
            See <a href="#WEBGLCONTEXTLOSTEVENT">WebGLContextLostEvent</a> for documentation of a
            WebGL-specific return value from getError.
        </dd><dt class="idl-code">void hint(GLenum target, GLenum mode)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glHint.xml">
                (OpenGL ES 2.0 man page)
            </a>
        </dt><dt class="idl-code">GLboolean isEnabled(GLenum cap)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glIsEnabled.xml">
                (OpenGL ES 2.0 man page)
            </a>
        </dt><dt class="idl-code">void lineWidth(GLfloat width)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glLineWidth.xml">
                (OpenGL ES 2.0 man page)
            </a>
        </dt><dt class="idl-code">void pixelStorei(GLenum pname, GLint param)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glPixelStorei.xml">
                (OpenGL ES 2.0 man page)
            </a>
            </dt><dd>
                In addition to the parameters in the OpenGL ES 2.0 specification, the WebGL
                specification accepts the parameters <code>UNPACK_FLIP_Y_WEBGL</code>
                and <code>UNPACK_PREMULTIPLY_ALPHA_WEBGL</code>. See <a href="#PIXEL_STORAGE_PARAMETERS">Pixel
                Storage Parameters</a> for documentation of these parameters.
        </dd><dt class="idl-code">void polygonOffset(GLfloat factor, GLfloat units)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glPolygonOffset.xml">
                (OpenGL ES 2.0 man page)
            </a>
        </dt><dt class="idl-code">void sampleCoverage(GLclampf value, GLboolean invert)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glSampleCoverage.xml">
                (OpenGL ES 2.0 man page)
            </a>
        </dt><dt class="idl-code">void stencilFunc(GLenum func, GLint ref, GLuint mask)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glStencilFunc.xml">
                (OpenGL ES 2.0 man page)
            </a>
        </dt><dt class="idl-code">void stencilFuncSeparate(GLenum face, GLenum func, GLint ref, GLuint mask)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glStencilFuncSeparate.xml">
                (OpenGL ES 2.0 man page)
            </a>
            </dt><dd>
                See <a href="#STENCIL_SEPARATE_LIMIT">Stencil Separate Mask and Reference Value</a> for information
                on WebGL specific limitations to the allowable argument values.
        </dd><dt class="idl-code">void stencilMask(GLuint mask)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glStencilMask.xml">
                (OpenGL ES 2.0 man page)
            </a>
            </dt><dd>
                See <a href="#STENCIL_SEPARATE_LIMIT">Stencil Separate Mask and Reference Value</a> for information
                on WebGL specific limitations to the allowable mask values.
        </dd><dt class="idl-code">void stencilMaskSeparate(GLenum face, GLuint mask)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glStencilMaskSeparate.xml">
                (OpenGL ES 2.0 man page)
            </a>
        </dt><dt class="idl-code">void stencilOp(GLenum fail, GLenum zfail, GLenum zpass)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glStencilOp.xml">
                (OpenGL ES 2.0 man page)
            </a>
        </dt><dt class="idl-code">void stencilOpSeparate(GLenum face, GLenum fail, GLenum zfail, GLenum zpass)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glStencilOpSeparate.xml">
                (OpenGL ES 2.0 man page)
            </a>
    </dt></dl>
     
<!-- ======================================================================================================= -->

    <h4 id="5.13.4"><span class="secno">5.13.4</span> Viewing and clipping</h4>

    <p>
        The viewport specifies the affine transformation of x and y from normalized device 
        coordinates to window coordinates. The size of the drawing buffer is determined by 
        the HTMLCanvasElement. The scissor box defines a rectangle which constrains drawing.
        When the scissor test is enabled only pixels that lie within  the scissor box can 
        be modified by drawing commands. When enabled drawing can only occur inside the 
        intersection of the viewport, canvas area and the scissor box. When the scissor test
        is not enabled drawing can only occur inside the intersection of the viewport and 
        canvas area.
    </p>

    <dl class="methods">
        <dt class="idl-code">void scissor(GLint x, GLint y, GLsizei width, GLsizei height)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glScissor.xml">
                (OpenGL ES 2.0 man page)
            </a>
        </dt><dt class="idl-code">void viewport(GLint x, GLint y, GLsizei width, GLsizei height)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glViewport.xml">
                (OpenGL ES 2.0 man page)
            </a>
    </dt></dl>
     
<!-- ======================================================================================================= -->

    <h4 id="5.13.5"><span class="secno">5.13.5</span> Buffer objects</h4>

    <p>
        Buffer objects (sometimes referred to as VBOs) hold vertex attribute data for the GLSL
        shaders.
    </p>
     
    <dl class="methods">
        <dt class="idl-code">void bindBuffer(GLenum target, WebGLBuffer buffer)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glBindBuffer.xml">
                (OpenGL ES 2.0 man page)
            </a>
        </dt><dd>
            Binds the given WebGLBuffer object to the given binding point (target), either
            ARRAY_BUFFER or ELEMENT_ARRAY_BUFFER. If the buffer is null then any buffer currently
            bound to this target is unbound. A given WebGLBuffer object may only be bound to one of
            the ARRAY_BUFFER or ELEMENT_ARRAY_BUFFER target in its lifetime. An attempt to bind a
            buffer object to the other target will generate an <code>INVALID_OPERATION</code> error, and the
            current binding will remain untouched.
        
        </dd><dt class="idl-code">void bufferData(GLenum target, GLsizei size, GLenum usage)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glBufferData.xml">
                (OpenGL ES 2.0 man page)
            </a>
        </dt><dd>
            Set the size of the currently bound WebGLBuffer object for the passed target. The
            buffer is initialized to 0.
            
        </dd><dt><p class="idl-code">void bufferData(GLenum target, ArrayBufferView data, GLenum usage)</p>
            <p class="idl-code">void bufferData(GLenum target, ArrayBuffer data, GLenum usage)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glBufferData.xml">
                (OpenGL ES 2.0 man page)
            </a></p>
        </dt><dd>
            Set the size of the currently bound WebGLBuffer object for the passed target to the 
            size of the passed data, then write the contents of data to the buffer object.
            
        </dd><dt><p class="idl-code">void bufferSubData(GLenum target, GLsizeiptr offset, ArrayBufferView data)</p>
            <p class="idl-code">void bufferSubData(GLenum target, GLsizeiptr offset, ArrayBuffer data)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glBufferSubData.xml">
                (OpenGL ES 2.0 man page)
            </a></p>
        </dt><dd>
            For the WebGLBuffer object bound to the passed target write the passed data starting
            at the passed offset. If the data would be written past the end of the buffer object
            an <code>INVALID_VALUE</code> error is generated.
            
        </dd><dt class="idl-code">WebGLBuffer createBuffer()
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glGenBuffers.xml">
                (OpenGL ES 2.0 man page)
            </a>
        </dt><dd>
            Create a WebGLBuffer object and initialize it with a buffer object name as if by
            calling glGenBuffers.
            
        </dd><dt class="idl-code">void deleteBuffer(WebGLBuffer buffer)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glDeleteBuffers.xml">
                (OpenGL ES 2.0 man page)
            </a>
        </dt><dd>
            Delete the buffer object contained in the passed WebGLBuffer as if by calling
            glDeleteBuffers. If the buffer has already been deleted the call has no effect.
            Note that the buffer object will be deleted when the WebGLBuffer object is destroyed.
            This method merely gives the author greater control over when the buffer object is
            destroyed.

        </dd><dt class="idl-code">any getBufferParameter(GLenum target, GLenum pname)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glGetBufferParameteriv.xml">
                (OpenGL ES 2.0 man page)
            </a>
        </dt><dd>
            Return the value for the passed pname. The type returned is the natural type for the
            requested pname, as given in the following table:
            <table class="foo">
                <tbody><tr><th>pname</th><th>returned type</th></tr>
                <tr><td>BUFFER_SIZE</td><td>long</td></tr>
                <tr><td>BUFFER_USAGE</td><td>unsigned long</td></tr>
            </tbody></table>
        </dd><dt class="idl-code">GLboolean isBuffer(WebGLBuffer buffer)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glIsBuffer.xml">
                (OpenGL ES 2.0 man page)
            </a>
    </dt></dl>

<!-- ======================================================================================================= -->

    <h4 id="5.13.6"><span class="secno">5.13.6</span> Framebuffer objects</h4>

    <p>
        Framebuffer objects provide an alternative rendering target to the drawing buffer. They
        are a collection of color, alpha, depth and stencil buffers and are often used to 
        render an image that will later be used as a texture.
    </p>
     
    <dl class="methods">
        <dt class="idl-code">void bindFramebuffer(GLenum target, WebGLFramebuffer framebuffer)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glBindFramebuffer.xml">
                (OpenGL ES 2.0 man page)
            </a>
        </dt><dd>
            Bind the given <code class="interface">WebGLFramebuffer</code> object to the given binding point
            (<code class="param">target</code>), which must be <code class="enum">FRAMEBUFFER</code>.
            If <code class="param">framebuffer</code> is null, the default framebuffer provided by the context
            is bound and attempts to modify or query state on <code class="param">target</code> <code class="enum">FRAMEBUFFER</code>
            will generate an <code class="error">INVALID_OPERATION</code> error.

        </dd><dt class="idl-code">GLenum checkFramebufferStatus(GLenum target)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glCheckFramebufferStatus.xml">
                (OpenGL ES 2.0 man page)
            </a>
        </dt><dt class="idl-code">WebGLFramebuffer createFramebuffer()
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glGenFramebuffers.xml">
                (OpenGL ES 2.0 man page)
            </a>
        </dt><dd>
            Create a WebGLFramebuffer object and initialize it with a framebuffer object name as if by
            calling glGenFramebuffers.
            
        </dd><dt class="idl-code">void deleteFramebuffer(WebGLFramebuffer buffer)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glDeleteFramebuffers.xml">
                (OpenGL ES 2.0 man page)
            </a>
        </dt><dd>
            Delete the framebuffer object contained in the passed WebGLFramebuffer as if by calling
            glDeleteFramebuffers. If the framebuffer has already been deleted the call has no effect.
            Note that the framebuffer object will be deleted when the WebGLFramebuffer object is destroyed.
            This method merely gives the author greater control over when the framebuffer object is
            destroyed.

        </dd><dt class="idl-code">void framebufferRenderbuffer(GLenum target, GLenum attachment, 
                                 GLenum renderbuffertarget, 
                                 WebGLRenderbuffer renderbuffer)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glFramebufferRenderbuffer.xml">
                (OpenGL ES 2.0 man page)
            </a></dt>
        <dt class="idl-code">void framebufferTexture2D(GLenum target, GLenum attachment, GLenum textarget, 
                              WebGLTexture texture, GLint level)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glFramebufferTexture2D.xml">
                (OpenGL ES 2.0 man page)
            </a>
        </dt><dt class="idl-code">any getFramebufferAttachmentParameter(GLenum target, GLenum attachment, 
                                          GLenum pname)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glGetFramebufferAttachmentParameteriv.xml">
                (OpenGL ES 2.0 man page)
            </a>
        </dt><dd>
            Return the value for the passed pname given the passed target and attachment. The type 
            returned is the natural type for the requested pname, as given in the following table:
            <table class="foo">
                <tbody><tr><th>pname</th><th>returned type</th></tr>
                <tr><td>FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE</td><td>unsigned long</td></tr>
                <tr><td>FRAMEBUFFER_ATTACHMENT_OBJECT_NAME</td><td>WebGLRenderbuffer or WebGLTexture</td></tr>
                <tr><td>FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL</td><td>long</td></tr>
                <tr><td>FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE</td><td>long</td></tr>
            </tbody></table>
        </dd><dt class="idl-code">GLboolean isFramebuffer(WebGLFramebuffer framebuffer)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glIsFramebuffer.xml">
                (OpenGL ES 2.0 man page)
            </a>
        </dt><dd>
            Return true if the passed WebGLFramebuffer is valid and false otherwise.
    </dd></dl>
     
<!-- ======================================================================================================= -->

    <h4 id="5.13.7"><span class="secno">5.13.7</span> Renderbuffer objects</h4>

    <p>
        Renderbuffer objects are used to provide storage for the individual buffers used in a
        framebuffer object.
    </p>
     
    <dl class="methods">
        <dt class="idl-code">void bindRenderbuffer(GLenum target, WebGLRenderbuffer renderbuffer)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glBindRenderbuffer.xml">
                (OpenGL ES 2.0 man page)
            </a>
        </dt><dd>
            Bind the given <code class="interface">WebGLRenderbuffer</code> object to the given binding point
            (<code class="param">target</code>), which must be <code class="enum">RENDERBUFFER</code>.
            If <code class="param">renderbuffer</code> is null the renderbuffer object currently bound to
            this <code class="param">target</code> is unbound.

        </dd><dt class="idl-code">WebGLRenderbuffer createRenderbuffer()
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glGenRenderbuffers.xml">
                (OpenGL ES 2.0 man page)
            </a>
        </dt><dd>
            Create a WebGLRenderbuffer object and initialize it with a renderbuffer object name as if by
            calling glGenRenderbuffers.
            
        </dd><dt class="idl-code">void deleteRenderbuffer(WebGLRenderbuffer renderbuffer)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glDeleteRenderbuffers.xml">
                (OpenGL ES 2.0 man page)
            </a>
        </dt><dd>
            Delete the renderbuffer object contained in the passed WebGLRenderbuffer as if by calling
            glDeleteRenderbuffers. If the renderbuffer has already been deleted the call has no effect.
            Note that the renderbuffer object will be deleted when the WebGLRenderbuffer object is destroyed.
            This method merely gives the author greater control over when the renderbuffer object is
            destroyed.
        </dd><dt class="idl-code">any getRenderbufferParameter(GLenum target, GLenum pname)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glGetRenderbufferParameteriv.xml">
                (OpenGL ES 2.0 man page)
            </a>
        </dt><dd>
            Return the value for the passed pname given the passed target. The type returned is the natural 
            type for the requested pname, as given in the following table:
            <table class="foo">
                <tbody><tr><th>pname</th><th>returned type</th></tr>
                <tr><td>RENDERBUFFER_WIDTH</td><td>long</td></tr>
                <tr><td>RENDERBUFFER_HEIGHT</td><td>long</td></tr>
                <tr><td>RENDERBUFFER_INTERNAL_FORMAT</td><td>unsigned long</td></tr>
                <tr><td>RENDERBUFFER_RED_SIZE</td><td>long</td></tr>
                <tr><td>RENDERBUFFER_GREEN_SIZE</td><td>long</td></tr>
                <tr><td>RENDERBUFFER_BLUE_SIZE</td><td>long</td></tr>
                <tr><td>RENDERBUFFER_ALPHA_SIZE</td><td>long</td></tr>
                <tr><td>RENDERBUFFER_DEPTH_SIZE</td><td>long</td></tr>
                <tr><td>RENDERBUFFER_STENCIL_SIZE</td><td>long</td></tr>
            </tbody></table>
        </dd><dt class="idl-code">GLboolean isRenderbuffer(WebGLRenderbuffer renderbuffer)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glIsRenderbuffer.xml">
                (OpenGL ES 2.0 man page)
            </a>
        </dt><dd>
            Return true if the passed WebGLRenderbuffer is valid and false otherwise.
        </dd><dt class="idl-code">void renderbufferStorage(GLenum target, GLenum internalformat, 
                             GLsizei width, GLsizei height)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glRenderbufferStorage.xml">
                (OpenGL ES 2.0 man page)
            </a>
    </dt></dl>

<!-- ======================================================================================================= -->

    <h4 id="5.13.8"><span class="secno">5.13.8</span> Texture objects</h4>

    <p>
        Texture objects provide storage and state for texturing operations. If no WebGLTexture is bound
        (e.g., passing null or 0 to bindTexture) then attempts to modify or query the texture object shall
        generate an <code>INVALID_OPERATION</code> error. This is indicated in the functions below.
    </p>
     
    <dl class="methods">
        <dt class="idl-code">void bindTexture(GLenum target, WebGLTexture texture)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glBindTexture.xml">
                (OpenGL ES 2.0 man page)
            </a>
        </dt><dt class="idl-code">void copyTexImage2D(GLenum target, GLint level, GLenum internalformat, 
                        GLint x, GLint y, GLsizei width, GLsizei height, 
                        GLint border)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glCopyTexImage2D.xml">
                (OpenGL ES 2.0 man page)
            </a>
        </dt><dd>
            If an attempt is made to call this function with no WebGLTexture bound (see above), an
            <code>INVALID_OPERATION</code> error is generated.
        </dd><dt class="idl-code">void copyTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, 
                           GLint x, GLint y, GLsizei width, GLsizei height)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glCopyTexSubImage2D.xml">
                (OpenGL ES 2.0 man page)
            </a>
        </dt><dd>
            If an attempt is made to call this function with no WebGLTexture bound (see above), an
            <code>INVALID_OPERATION</code> error is generated.
        </dd><dt class="idl-code">WebGLTexture createTexture()
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glGenTextures.xml">
                (OpenGL ES 2.0 man page)
            </a>
        </dt><dd>
            Create a WebGLTexture object and initialize it with a texture object name as if by
            calling glGenTextures.
            
        </dd><dt class="idl-code">void deleteTexture(WebGLTexture texture)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glDeleteTextures.xml">
                (OpenGL ES 2.0 man page)
            </a>
        </dt><dd>
            Delete the texture object contained in the passed WebGLTexture as if by calling
            glDeleteTextures. If the texture has already been deleted the call has no effect.
            Note that the texture object will be deleted when the WebGLTexture object is destroyed.
            This method merely gives the author greater control over when the texture object is
            destroyed.
        </dd><dt class="idl-code">void generateMipmap(GLenum target)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glGenerateMipmap.xml">
                (OpenGL ES 2.0 man page)
            </a>
        </dt><dd>
            If an attempt is made to call this function with no WebGLTexture bound (see above), an
            <code>INVALID_OPERATION</code> error is generated.
        </dd><dt class="idl-code">any getTexParameter(GLenum target, GLenum pname)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glGetTexParameter.xml">
                (OpenGL ES 2.0 man page)
            </a>
        </dt><dd>
            Return the value for the passed pname given the passed target. The type returned is the natural type for the
            requested pname, as given in the following table:
            <table class="foo">
                <tbody><tr><th>pname</th><th>returned type</th></tr>
                <tr><td>TEXTURE_MAG_FILTER</td><td>unsigned long</td></tr>
                <tr><td>TEXTURE_MIN_FILTER</td><td>unsigned long</td></tr>
                <tr><td>TEXTURE_WRAP_S</td><td>unsigned long</td></tr>
                <tr><td>TEXTURE_WRAP_T</td><td>unsigned long</td></tr>
            </tbody></table>
        </dd><dd>
            If an attempt is made to call this function with no WebGLTexture bound (see above), an
            <code>INVALID_OPERATION</code> error is generated.
        </dd><dt class="idl-code">GLboolean isTexture(WebGLTexture texture)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glIsTexture.xml">
                (OpenGL ES 2.0 man page)
            </a>
        </dt><dd>
            Return true if the passed WebGLTexture is valid and false otherwise.
        </dd><dt class="idl-code"><a name="TEXIMAGE2D">void texImage2D</a>(GLenum target, GLint level, GLenum internalformat, 
                    GLsizei width, GLsizei height, GLint border, GLenum format, 
                    GLenum type, ArrayBufferView pixels)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glTexImage2D.xml">
                (OpenGL ES 2.0 man page)
            </a>
        </dt><dd>
            If <code>pixels</code> is null, a buffer of sufficient size initialized to 0 is
            passed. <br><br>

            If <code>pixels</code> is non-null, the type of <code>pixels</code> must match the type
            of the data to be read. If it is UNSIGNED_BYTE, a Uint8Array must be supplied; if it is
            UNSIGNED_SHORT_5_6_5, UNSIGNED_SHORT_4_4_4_4, or UNSIGNED_SHORT_5_5_5_1, a Uint16Array
            must be supplied. If the types do not match, an INVALID_OPERATION error is generated.
            <br><br>

            If an attempt is made to call this function with no WebGLTexture bound (see above), an
            <code>INVALID_OPERATION</code> error is generated. <br><br>

            See <a href="#PIXEL_STORAGE_PARAMETERS">Pixel Storage Parameters</a> for WebGL-specific
            pixel storage parameters that affect the behavior of this function.
        </dd><dt><p class="idl-code"><a name="TEXIMAGE2D_HTML">void texImage2D</a>(GLenum target, GLint level, GLenum internalformat,
                    GLenum format, GLenum type, ImageData pixels)</p>
            <p class="idl-code">void texImage2D(GLenum target, GLint level, GLenum internalformat,
                    GLenum format, GLenum type, HTMLImageElement image)</p>
            <p class="idl-code">void texImage2D(GLenum target, GLint level, GLenum internalformat,
                    GLenum format, GLenum type, HTMLCanvasElement canvas)</p>
            <p class="idl-code">void texImage2D(GLenum target, GLint level, GLenum internalformat,
                    GLenum format, GLenum type, HTMLVideoElement video)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glTexImage2D.xml">
                (OpenGL ES 2.0 man page)
            </a></p>
        </dt><dd>
            Uploads the given element or image data to the currently bound WebGLTexture. <br><br>

            The source image data is conceptually first converted to the data type and format
            specified by the <em>format</em> and <em>type</em> arguments, and then transferred to
            the OpenGL implementation. If a packed pixel format is specified which would imply loss
            of bits of precision from the image data, this loss of precision must occur. <br><br>

            If the source image is an RGB or RGBA lossless image with 8 bits per channel, the
            browser guarantees that the full precision of all channels is preserved. <br><br>

            If the original image semantically contains an alpha channel and the
            <code>UNPACK_PREMULTIPLY_ALPHA_WEBGL</code> pixel storage parameter is false, then the
            alpha channel is guaranteed to never have been premultiplied by the RGB values, whether
            those values are derived directly from the original file format or converted from some
            other color format. <br><br>

            If an attempt is made to call this function with no WebGLTexture bound (see above), an
            <code>INVALID_OPERATION</code> error is generated. <br><br>

            See <a href="#PIXEL_STORAGE_PARAMETERS">Pixel Storage Parameters</a> for WebGL-specific
            pixel storage parameters that affect the behavior of this function.
        </dd><dt class="idl-code">void texParameterf(GLenum target, GLenum pname, GLfloat param)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glTexParameter.xml">
                (OpenGL ES 2.0 man page)
            </a>
        </dt><dd>
            If an attempt is made to call this function with no WebGLTexture bound (see above), an
            <code>INVALID_OPERATION</code> error is generated.
        </dd><dt class="idl-code">void texParameteri(GLenum target, GLenum pname, GLint param)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glTexParameter.xml">
                (OpenGL ES 2.0 man page)
            </a>
        </dt><dd>
            If an attempt is made to call this function with no WebGLTexture bound (see above), an
            <code>INVALID_OPERATION</code> error is generated.
        </dd><dt class="idl-code">void texSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, 
                       GLsizei width, GLsizei height, 
                       GLenum format, GLenum type, ArrayBufferView pixels)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glTexSubImage2D.xml">
                (OpenGL ES 2.0 man page)
            </a>
        </dt><dd>
            See <a href="#TEXIMAGE2D">texImage2D</a> for restrictions on the <em>format</em>
            and <em>pixels</em> arguments. <br><br>

            If an attempt is made to call this function with no WebGLTexture bound (see above), an
            <code>INVALID_OPERATION</code> error is generated. <br><br>

            See <a href="#PIXEL_STORAGE_PARAMETERS">Pixel Storage Parameters</a> for WebGL-specific
            pixel storage parameters that affect the behavior of this function.
        </dd><dt><p class="idl-code">void texSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, 
                       GLenum format, GLenum type, ImageData pixels)</p>
            <p class="idl-code">void texSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, 
                       GLenum format, GLenum type, HTMLImageElement image)</p>
            <p class="idl-code">void texSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, 
                       GLenum format, GLenum type, HTMLCanvasElement canvas)</p>
            <p class="idl-code">void texSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, 
                       GLenum format, GLenum type, HTMLVideoElement video)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glTexSubImage2D.xml">
                (OpenGL ES 2.0 man page)
            </a></p>
        </dt><dd>
            Updates a sub-rectangle of the currently bound WebGLTexture with the contents of the
            given element or image data. <br><br>

            See <a href="#TEXIMAGE2D_HTML">texImage2D</a> for the interpretation of
            the <em>format</em> and <em>type</em> arguments. <br><br>

            If an attempt is made to call this function with no WebGLTexture bound (see above), an
            <code>INVALID_OPERATION</code> error is generated. <br><br>

            See <a href="#PIXEL_STORAGE_PARAMETERS">Pixel Storage Parameters</a> for WebGL-specific
            pixel storage parameters that affect the behavior of this function.
    </dd></dl>
     
<!-- ======================================================================================================= -->

    <h4 id="5.13.9"><span class="secno">5.13.9</span> Programs and Shaders</h4>

    <p>
        Rendering with OpenGL ES 2.0 requires the use of <i>shaders</i>, written in OpenGL ES's shading language, GLSL ES.
        Shaders must be loaded with a source string (shaderSource), compiled
        (compileShader) and attached to a <i>program</i> (attachShader) which must be linked
        (linkProgram) and then used (useProgram).
    </p>

    <dl class="methods">
        <dt class="idl-code">void attachShader(WebGLProgram program, WebGLShader shader)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glAttachShader.xml">
                (OpenGL ES 2.0 man page)
            </a>
        </dt><dt class="idl-code">void bindAttribLocation(WebGLProgram program, GLuint index, DOMString name)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glBindAttribLocation.xml">
                (OpenGL ES 2.0 man page)
            </a>
        </dt><dt class="idl-code">void compileShader(WebGLShader shader)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glCompileShader.xml">
                (OpenGL ES 2.0 man page)
            </a>
        </dt><dt class="idl-code">WebGLProgram createProgram()
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glCreateProgram.xml">
                (OpenGL ES 2.0 man page)
            </a>
        </dt><dd>
            Create a WebGLProgram object and initialize it with a program object name as if by
            calling glCreateProgram.
            
        </dd><dt class="idl-code">WebGLShader createShader(type)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glCreateShader.xml">
                (OpenGL ES 2.0 man page)
            </a>
        </dt><dd>
            Create a WebGLShader object and initialize it with a shader object name as if by
            calling glCreateShader.
            
        </dd><dt class="idl-code">void deleteProgram(WebGLProgram program)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glDeleteProgram.xml">
                (OpenGL ES 2.0 man page)
            </a>
        </dt><dd>
            Delete the program object contained in the passed WebGLProgram as if by calling
            glDeleteProgram. If the program has already been deleted the call has no effect.
            Note that the program object will be deleted when the WebGLProgram object is destroyed.
            This method merely gives the author greater control over when the program object is
            destroyed.
        </dd><dt class="idl-code">void deleteShader(WebGLShader shader)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glDeleteShader.xml">
                (OpenGL ES 2.0 man page)
            </a>
        </dt><dd>
            Delete the shader object contained in the passed WebGLShader as if by calling
            glDeleteShader. If the shader has already been deleted the call has no effect.
            Note that the shader object will be deleted when the WebGLShader object is destroyed.
            This method merely gives the author greater control over when the shader object is
            destroyed.
        </dd><dt class="idl-code">void detachShader(WebGLProgram program, WebGLShader shader)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glDetachShader.xml">
                (OpenGL ES 2.0 man page)
            </a>
        </dt><dt class="idl-code">WebGLShader[ ] getAttachedShaders(WebGLProgram program)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glGetAttachedShaders.xml">
                (OpenGL ES 2.0 man page)
            </a>
        </dt><dd>
            Return the list of shaders attached to the passed program.
        </dd><dt class="idl-code">any getProgramParameter(WebGLProgram program, GLenum pname)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glGetProgramiv.xml">
                (OpenGL ES 2.0 man page)
            </a>
        </dt><dd>
            Return the value for the passed pname given the passed program. The type returned is the natural 
            type for the requested pname, as given in the following table:
            <table class="foo">
                <tbody><tr><th>pname</th><th>returned type</th></tr>
                <tr><td>DELETE_STATUS</td><td>boolean</td></tr>
                <tr><td>LINK_STATUS</td><td>boolean</td></tr>
                <tr><td>VALIDATE_STATUS</td><td>boolean</td></tr>
                <tr><td>INFO_LOG_LENGTH</td><td>long</td></tr>
                <tr><td>ATTACHED_SHADERS</td><td>long</td></tr>
                <tr><td>ACTIVE_ATTRIBUTES</td><td>long</td></tr>
                <tr><td>ACTIVE_ATTRIBUTE_MAX_LENGTH</td><td>long</td></tr>
                <tr><td>ACTIVE_UNIFORMS</td><td>long</td></tr>
                <tr><td>ACTIVE_UNIFORM_MAX_LENGTH</td><td>long</td></tr>
            </tbody></table>
        </dd><dt class="idl-code">DOMString getProgramInfoLog(WebGLProgram program)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glGetProgramInfoLog.xml">
                (OpenGL ES 2.0 man page)
            </a>
        </dt><dt class="idl-code">any getShaderParameter(WebGLShader shader, GLenum pname)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glGetShaderiv.xml">
                (OpenGL ES 2.0 man page)
            </a>
        </dt><dd>
            Return the value for the passed pname given the passed shader. The type returned is the natural 
            type for the requested pname, as given in the following table:
            <table class="foo">
                <tbody><tr><th>pname</th><th>returned type</th></tr>
                <tr><td>SHADER_TYPE</td><td>unsigned long</td></tr>
                <tr><td>DELETE_STATUS</td><td>boolean</td></tr>
                <tr><td>COMPILE_STATUS</td><td>boolean</td></tr>
                <tr><td>INFO_LOG_LENGTH</td><td>long</td></tr>
                <tr><td>SHADER_SOURCE_LENGTH</td><td>long</td></tr>
            </tbody></table>
        </dd><dt class="idl-code">DOMString getShaderInfoLog(WebGLShader shader)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glGetShaderInfoLog.xml">
                (OpenGL ES 2.0 man page)
            </a>
        </dt><dt class="idl-code">DOMString getShaderSource(WebGLShader shader)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glGetShaderSource.xml">
                (OpenGL ES 2.0 man page)
            </a>
        </dt><dt class="idl-code">GLboolean isProgram(WebGLProgram program)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glIsProgram.xml">
                (OpenGL ES 2.0 man page)
            </a>
        </dt><dd>
            Return true if the passed WebGLProgram is valid and false otherwise.
        </dd><dt class="idl-code">GLboolean isShader(WebGLShader shader)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glIsShader.xml">
                (OpenGL ES 2.0 man page)
            </a>
        </dt><dd>
            Return true if the passed WebGLShader is valid and false otherwise.
        </dd><dt class="idl-code">void linkProgram(WebGLProgram program)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glLinkProgram.xml">
                (OpenGL ES 2.0 man page)
            </a>
        </dt><dt class="idl-code">void shaderSource(WebGLShader shader, DOMString source)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glShaderSource.xml">
                (OpenGL ES 2.0 man page)
            </a>
        </dt><dt class="idl-code">void useProgram(WebGLProgram program)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glUseProgram.xml">
                (OpenGL ES 2.0 man page)
            </a>
        </dt><dt class="idl-code">void validateProgram(WebGLProgram program)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glValidateProgram.xml">
                (OpenGL ES 2.0 man page)
            </a>
    </dt></dl>
    
<!-- ======================================================================================================= -->

    <h4 id="5.13.10"><span class="secno">5.13.10</span> Uniforms and attributes</h4>

    <p>
        Values used by the shaders are passed in as uniform of vertex attributes.
    </p>
     
    <dl class="methods">
        <dt class="idl-code">void disableVertexAttribArray(GLuint index)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glDisableVertexAttribArray.xml">
                (OpenGL ES 2.0 man page)
            </a>
        </dt><dt class="idl-code">void enableVertexAttribArray(GLuint index)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glEnableVertexAttribArray.xml">
                (OpenGL ES 2.0 man page)
            </a>
        </dt><dd>
            Enable the vertex attribute at <code>index</code> as an array. WebGL imposes additional
            rules beyond OpenGL ES 2.0 regarding enabled vertex attributes;
            see <a href="#ATTRIBS_AND_RANGE_CHECKING">Enabled Vertex Attributes and Range
            Checking</a>.
        </dd><dt class="idl-code">WebGLActiveInfo getActiveAttrib(WebGLProgram program, GLuint index)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glGetActiveAttrib.xml">
                (OpenGL ES 2.0 man page)
            </a>
        </dt><dd>
            Returns information about the size, type and name of the vertex attribute at the
            passed index of the passed program object.
        </dd><dt class="idl-code">WebGLActiveInfo getActiveUniform(WebGLProgram program, GLuint index)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glGetActiveUniform.xml">
                (OpenGL ES 2.0 man page)
            </a>
        </dt><dd>
            Returns information about the size, type and name of the uniform at the
            passed index of the passed program object.
        </dd><dt class="idl-code">GLint getAttribLocation(WebGLProgram program, DOMString name)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glGetAttribLocation.xml">
                (OpenGL ES 2.0 man page)
            </a>
        </dt><dt class="idl-code">any getUniform(WebGLProgram program, WebGLUniformLocation location)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glGetUniform.xml">
                (OpenGL ES 2.0 man page)
            </a>
        </dt><dd>
            Return the uniform value at the passed location in the passed program. The type returned is 
            dependent on the uniform type, as shown in the following table:
            <table class="foo">
                <tbody><tr><th>uniform type</th><th>returned type</th></tr>
                <tr><td>boolean</td><td>boolean</td></tr>
                <tr><td>int</td><td>long</td></tr>
                <tr><td>float</td><td>float</td></tr>
                <tr><td>vec2</td><td>Float32Array (with 2 elements)</td></tr>
                <tr><td>ivec2</td><td>Int32Array (with 2 elements)</td></tr>
                <tr><td>bvec2</td><td>Uint8Array (with 2 elements)</td></tr>
                <tr><td>vec3</td><td>Float32Array (with 3 elements)</td></tr>
                <tr><td>ivec3</td><td>Int32Array (with 3 elements)</td></tr>
                <tr><td>bvec3</td><td>Uint8Array (with 3 elements)</td></tr>
                <tr><td>vec4</td><td>Float32Array (with 4 elements)</td></tr>
                <tr><td>ivec4</td><td>Int32Array (with 4 elements)</td></tr>
                <tr><td>bvec4</td><td>Uint8Array (with 4 elements)</td></tr>
                <tr><td>mat2</td><td>Float32Array (with 4 elements)</td></tr>
                <tr><td>mat3</td><td>Float32Array (with 9 elements)</td></tr>
                <tr><td>mat4</td><td>Float32Array (with 16 elements)</td></tr>
            </tbody></table>
        </dd><dt class="idl-code">WebGLUniformLocation getUniformLocation(WebGLProgram program, DOMString name)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glGetUniformLocation.xml">
                (OpenGL ES 2.0 man page)
            </a>
        </dt><dd>
            Return a WebGLUniformLocation object that represents the location of a specific uniform variable
            within a program object. The return value is null if name does not correspond to an active uniform
            variable in the passed program.

        </dd><dt class="idl-code">any getVertexAttrib(GLuint index, GLenum pname)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glGetVertexAttrib.xml">
                (OpenGL ES 2.0 man page)
            </a>
        </dt><dd>
            Return the information requested in pname about the vertex attribute at the passed index. The 
            type returned is dependent on the information requested, as shown in the following table:
            <table class="foo">
                <tbody><tr><th>pname</th><th>returned type</th></tr>
                <tr><td>VERTEX_ATTRIB_ARRAY_BUFFER_BINDING</td><td>WebGLBuffer</td></tr>
                <tr><td>VERTEX_ATTRIB_ARRAY_ENABLED</td><td>boolean</td></tr>
                <tr><td>VERTEX_ATTRIB_ARRAY_SIZE</td><td>long</td></tr>
                <tr><td>VERTEX_ATTRIB_ARRAY_STRIDE</td><td>long</td></tr>
                <tr><td>VERTEX_ATTRIB_ARRAY_TYPE</td><td>unsigned long</td></tr>
                <tr><td>VERTEX_ATTRIB_ARRAY_NORMALIZED</td><td>boolean</td></tr>
                <tr><td>CURRENT_VERTEX_ATTRIB</td><td>Float32Array (with 4 elements)</td></tr>
            </tbody></table>
        </dd><dt class="idl-code">GLsizeiptr getVertexAttribOffset(GLuint index, GLenum pname)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glGetVertexAttribPointerv.xml">
                (OpenGL ES 2.0 man page)
            </a>
        </dt><dt><p class="idl-code">void uniform[1234][fi](WebGLUniformLocation location, ...)</p>
            <p class="idl-code">void uniform[1234][fi]v(WebGLUniformLocation location, ...)
            </p><p class="idl-code">void uniformMatrix[234]fv(WebGLUniformLocation location, GLboolean transpose, ...)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glUniform.xml">
                (OpenGL ES 2.0 man page)
            </a></p>
       </dt><dd>
            Each of the uniform* functions above sets the specified uniform or uniforms to the
            values provided. If the passed <code>location</code> is not null and was not obtained
            from the currently used program via an earlier call to <code>getUniformLocation</code>,
            an <code>INVALID_OPERATION</code> error will be generated. If the passed
            <code>location</code> is null, the data passed in will be silently ignored and the
            specified uniform variable will not be changed.
        </dd><dt><p class="idl-code">void vertexAttrib[1234]f(GLuint indx, ...)</p>
            <p class="idl-code">void vertexAttrib[1234]fv(GLuint indx, ...)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glVertexAttrib.xml">
                (OpenGL ES 2.0 man page)
            </a></p>
       </dt><dd>
           Sets the vertex attribute at the passed index to the given constant value.
       </dd><dt class="idl-code">void vertexAttribPointer(GLuint indx, GLint size, GLenum type, 
                            GLboolean normalized, GLsizei stride, GLsizeiptr offset)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glVertexAttribPointer.xml">
                (OpenGL ES 2.0 man page)
            </a>
        </dt><dd>
            Assign the WebGLBuffer object currently bound to the ARRAY_BUFFER target to the vertex
            attribute at the passed index. Size is number of components per attribute. Stride and
            offset are in units of bytes. Passed stride and offset must be appropriate for the
            passed type and size or an <code>INVALID_VALUE</code> error will be generated. If no
            WebGLBuffer is bound to the ARRAY_BUFFER target, an <code>INVALID_OPERATION</code> error
            will be generated. In WebGL, the maximum supported stride is 255; see <a href="#VERTEX_STRIDE">
            Vertex Attribute Data Stride</a>.
    </dd></dl>
    
<!-- ======================================================================================================= -->

    <h4 id="5.13.11"><span class="secno">5.13.11</span> Writing to the drawing buffer</h4>

    <p>
        OpenGL ES 2.0 has 3 calls which can render to the drawing buffer: <code>clear</code>, 
        <code>drawArrays</code> and <code>drawElements</code>. Furthermore rendering can
        be directed to the drawing buffer or to a Framebuffer object. When rendering is
        directed to the drawing buffer, making any of the 3 rendering calls shall 
        cause the drawing buffer to be presented to the HTML page compositor at the start
        of the next compositing operation.
    </p>
     
    <dl class="methods">
        <dt class="idl-code">void clear(GLbitfield mask)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glClear.xml">
                (OpenGL ES 2.0 man page)
            </a>
        </dt><dt class="idl-code">void drawArrays(GLenum mode, GLint first, GLsizei count)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glDrawArrays.xml">
                (OpenGL ES 2.0 man page)
            </a>
            </dt><dd>
            If <em>first</em> is negative, an <code>INVALID_VALUE</code> error will be generated.
        </dd><dt class="idl-code">void drawElements(GLenum mode, GLsizei count, GLenum type, GLsizeiptr offset)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glDrawElements.xml">
                (OpenGL ES 2.0 man page)
            </a>
        </dt><dd>
            Draw using the currently bound index array.  The given
            offset is in bytes, and must be a valid multiple of the
            size of the given type or an <code>INVALID_VALUE</code> error will be
            generated. <br><br>

            WebGL performs additional error checking beyond that specified in OpenGL ES 2.0 during
            calls to <code>drawArrays</code>
            and <code>drawElements</code>. See <a href="#ATTRIBS_AND_RANGE_CHECKING">Enabled Vertex
            Attributes and Range Checking</a>.
        </dd><dt class="idl-code">void finish()
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glFinish.xml">
                (OpenGL ES 2.0 man page)
            </a>
        </dt><dt class="idl-code">void flush()
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glFlush.xml">
                (OpenGL ES 2.0 man page)
            </a>
    </dt></dl>

<!-- ======================================================================================================= -->

    <h4 id="5.13.12"><span class="secno">5.13.12</span> Reading back pixels</h4>

    <p>
        Pixels in the current framebuffer can be read back into an ArrayBufferView object.
    </p>

    <dl class="methods">
        <dt class="idl-code">void readPixels(GLint x, GLint y, GLsizei width, GLsizei height, 
                           GLenum format, GLenum type, ArrayBufferView pixels)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glReadPixels.xml">
                (OpenGL ES 2.0 man page)
            </a>
        </dt><dd>
            Fills <code>pixels</code> with the pixel data in the specified rectangle of the frame
            buffer. The data returned from readPixels must be up-to-date as of the most recently
            sent drawing command.
            <br><br>

            The type of <code>pixels</code> must match the type of the data to be read. If it is
            UNSIGNED_BYTE, a Uint8Array must be supplied; if it is UNSIGNED_SHORT_5_6_5,
            UNSIGNED_SHORT_4_4_4_4, or UNSIGNED_SHORT_5_5_5_1, a Uint16Array must be supplied. If
            the types do not match, an INVALID_OPERATION error is generated.
            <br><br>

            If <code>pixels</code> is null, an INVALID_VALUE error is generated. If
            <code>pixels</code> is non-null, but is not large enough to retrieve all of the pixels
            in the specified rectangle taking into account pixel store modes, an INVALID_OPERATION
            value is generated.
            <br><br>

            For any pixel lying outside the frame buffer, the value read contains 0 in all channels.
            <br><br>

    </dd></dl>
    
<!-- ======================================================================================================= -->

    <h4 id="5.13.13"><span class="secno">5.13.13</span> Detecting context lost events</h4>

    <p>
        Occurrences such as power events on mobile devices may cause the WebGL rendering context to
        be lost at any time and require the application to rebuild it;
        see <a href="#WEBGLCONTEXTLOSTEVENT">WebGLContextLostEvent</a>
        and <a href="#WEBGLCONTEXTRESTOREDEVENT">WebGLContextRestoredEvent</a> for more details. The
        following method assists in detecting context lost events.
    </p>

    <dl class="methods">
        <dt class="idl-code">boolean isContextLost()
        </dt><dd>
            Returns true if the context is in the lost state.
    </dd></dl>
    
<!-- ======================================================================================================= -->

    <h4 id="5.13.14"><span class="secno">5.13.14</span> Detecting and enabling extensions</h4>

    <p>
        An implementation of WebGL must not support any additional parameters, constants or functions
        without first enabling that functionality through the extension mechanism. The 
        <code>getSupportedExtensions</code> function returns an array of the extension strings supported
        by this implementation. Extension strings are case-insensitive. An extension is enabled by 
        passing one of those strings to the <code>getExtension</code> function. This call returns an 
        object which contains any constants or functions defined by that extension. The definition of 
        that object is specific to the extension and must be defined by the extension specification.
    </p>
    <p>
        Once an extension is enabled, no mechanism is provided to disable it. Multiple calls to
        <code>getExtension</code> with the same extension string shall return the same object. An 
        attempt to use any features of an extension without first calling getExtension to enable it 
        must generate an appropriate GL error and must not make use of the feature.
    </p>
    <p>
        This specification does not define any extensions. Browser specific extensions must have a 
        browser specific prefix, (e.g., "webkit-" or "moz-"). 
    </p>

    <dl class="methods">
        <dt class="idl-code">DOMString[ ] getSupportedExtensions()
        </dt><dd>
            Returns an array of all the supported extension strings. Any string in this list, when 
            passed to <code>getExtension</code> must return a valid object. Any other string passed to 
            <code>getExtension</code> must return null.
            
        </dd><dt class="idl-code">object getExtension(DOMString name)
        </dt><dd>
            Returns an object if the passed extension is supported, or null if not. The object 
            returned from <code>getExtension</code> contains any constants or functions used by the 
            extension, if any. A returned object may have no constants or functions if the extension does 
            not define any, but a unique object must still be returned. That object is used to indicate 
            that the extension has been enabled. 
    </dd></dl>

<!-- ======================================================================================================= -->

    <h3 id="5.14"><span class="secno">5.14</span> Events</h3>

    <p>
        WebGL generates events when certain system activity occurs affecting the context.
        These events are sent to the corresponding HTMLCanvasElement through the
        <a href="http://www.w3.org/TR/DOM-Level-2-Events/events.html">DOM Event System</a>.
    </p>

<!-- ======================================================================================================= -->

    <h4 id="5.14.1"><span class="secno">5.14.1</span> <a name="WEBGLCONTEXTLOSTEVENT">WebGLContextLostEvent</a></h4>

    <p>
        This event occurs when some system activity external to WebGL causes the rendering context
        to lose all of its state. The <span class="prop-name"><code>context</code></span> attribute
        contains the WebGLRenderingContext whose state was lost.
    </p>
    <p>
        When a WebGLContextLostEvent is delivered for a given context, that context is in a "lost"
        state. While the context is in the lost state:

        </p><ul>
        <li> The context's <code>isContextLost</code> method returns <code>true</code>. 
        </li><li> All methods returning <code>void</code> return immediately.
        </li><li> All methods returning nullable values or <code>any</code> return <code>null</code>.
        </li><li> <code>checkFramebufferStatus</code> returns <code>FRAMEBUFFER_UNSUPPORTED</code>.
        </li><li> <code>getAttribLocation</code> returns <code>-1</code>.
        </li><li> <code>getError</code> returns <code>CONTEXT_LOST_WEBGL</code> the first time it is
             called while the context is lost. Afterward it will return <code>NO_ERROR</code> until
             the context has been restored.
        </li><li> <code>getVertexAttribOffset</code> returns <code>0</code>.
        </li><li> All <code>is</code> queries return <code>false</code>.
        </li></ul>
    <p></p>
    <p>
        See the specification of the
        <a href="#WEBGLCONTEXTRESTOREDEVENT">WebGLContextRestoredEvent</a> for information on
        resuming rendering after the context has been lost.
    </p>
    <pre class="idl">interface <dfn id="WebGLContextLostEvent">WebGLContextLostEvent</dfn> : Event {
    readonly attribute WebGLRenderingContext context;
    
    void initWebGLContextLostEvent(DOMString type,
                                   boolean canBubble,
                                   boolean cancelable,
                                   WebGLRenderingContext context);
};</pre>

    <h5 id="5.14.1.1"><span class="secno">5.14.1.1</span> Attributes</h5>

    <p>
        The following attributes are available:
    </p>

    <dl class="methods">
        <dt><span class="prop-name"><code>context</code></span> of type <code>WebGLRenderingContext</code>
        </dt><dd>
            The context whose state was lost.
    </dd></dl>

    <h5 id="5.14.1.2"><span class="secno">5.14.1.2</span> Methods</h5>

    <p>
        The following methods are available:
    </p>

    <dl class="methods">
        <dt class="idl-code">void initWebGLContextLostEvent(DOMString type, boolean canBubble, boolean cancelable, WebGLRenderingContext context)
        </dt><dd>
            Initialize the event created through the 
            <a href="http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-Event">Event</a>
            interface. This method may only be called before the event has been dispatched via
            the <code>dispatchEvent</code> method, though it may be called multiple times during
            that phase if necessary. If called multiple times, the final invocation takes
            precedence.
            <p>
            <b>Parameters</b>
            </p><dl>
                <dt><code>type</code> of type <code>DOMString</code>
                </dt><dd>Specifies the event type, which is the string <code>webglcontextlost</code>.
                </dd><dt><code>canBubble</code> of type <code>boolean</code>
                </dt><dd>Specifies whether or not the event can bubble.
                </dd><dt><code>cancelable</code> of type <code>boolean</code>
                </dt><dd>Specifies whether or not the event can bubble.
                </dd><dt><code>context</code> of type <code>WebGLRenderingContext</code>
                </dt><dd>The context whose state was lost.
            </dd></dl>
            <b>No Return Value</b><br>
            <b>No Exceptions</b><br>
    </dd></dl>

<!-- ======================================================================================================= -->

    <h4 id="5.14.2"><span class="secno">5.14.2</span> <a name="WEBGLCONTEXTRESTOREDEVENT">WebGLContextRestoredEvent</a></h4>

    <p>
        This event occurs when the WebGL implementation determines that a previously lost context
        can be restored. <em>The system only restores the context if a handler for the context
        restored event is installed on the Canvas element.</em>
    </p>
    <p>
        Once the context is restored, WebGL resources such as textures and buffers that were created
        before the context was lost are no longer valid. The application must reinitialize the
        context's state and recreate all such resources.
    </p>
    <pre class="idl">interface <dfn id="WebGLContextRestoredEvent">WebGLContextRestoredEvent</dfn> : Event {
    readonly attribute WebGLRenderingContext context;
    
    void initWebGLContextRestoredEvent(DOMString type,
                                       boolean canBubble,
                                       boolean cancelable,
                                       WebGLRenderingContext context);
};</pre>

    <h5 id="5.14.2.1"><span class="secno">5.14.2.1</span> Attributes</h5>

    <p>
        The following attributes are available:
    </p>

    <dl class="methods">
        <dt><span class="prop-name"><code>context</code></span> of type <code>WebGLRenderingContext</code>
        </dt><dd>
            The context whose state was restored.
    </dd></dl>

    <h5 id="5.14.2.2"><span class="secno">5.14.2.2</span> Methods</h5>

    <p>
        The following methods are available:
    </p>

    <dl class="methods">
        <dt class="idl-code">void initWebGLContextRestoredEvent(DOMString type, boolean canBubble, boolean cancelable, WebGLRenderingContext context)
        </dt><dd>
            Initialize the event created through the 
            <a href="http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-Event">Event</a>
            interface. This method may only be called before the event has been dispatched via
            the <code>dispatchEvent</code> method, though it may be called multiple times during
            that phase if necessary. If called multiple times, the final invocation takes
            precedence.
            <p>
            <b>Parameters</b>
            </p><dl>
                <dt><code>type</code> of type <code>DOMString</code>
                </dt><dd>Specifies the event type, which is the string <code>webglcontextrestored</code>.
                </dd><dt><code>canBubble</code> of type <code>boolean</code>
                </dt><dd>Specifies whether or not the event can bubble.
                </dd><dt><code>cancelable</code> of type <code>boolean</code>
                </dt><dd>Specifies whether or not the event can bubble.
                </dd><dt><code>context</code> of type <code>WebGLRenderingContext</code>
                </dt><dd>The context whose state was lost.
            </dd></dl>
            <b>No Return Value</b><br>
            <b>No Exceptions</b><br>
    </dd></dl>

    <div class="example">
    The following ECMAScript example shows how to register event listeners on a Canvas called
    <code>canvas1</code> which will receive context lost and restored events and restart the
    application. For completeness, it illustrates how an application performing asynchronous image
    loading would handle a context lost event at an arbitrary point in time.
    <pre>window.onload = init;

var g_gl;
var g_canvas;
var g_intervalId;
var g_images = [];
var g_imgURLs = [
 "someimage.jpg",
 "someotherimage.jpg",
 "yetanotherimage.png"
];

function init() {
  g_canvas = document.getElementById("canvas1");
  g_canvas.addEventListener("webglcontextlost", contextLostHandler, false);
  g_canvas.addEventListener("webglcontextrestored", contextRestoredHandler, false);
  g_gl = canvas.getContext("webgl");

  for (var ii = 0; ii &lt; g_imgURLs.length; ++ii) {
    // Create an image tag.
    var image = document.createElement('img');

    // Create a texture for this image.
    image.texture = g_gl.createTexture();

    // Mark the image as not loaded.
    image.loaded = false;

    // Setup a load callback.
    image.onload = (function(image) {
        return function() {
          imageLoadedHandler(image);
        };
      }(image));

    // Start the image loading.
    image.src = g_imgURLs[ii];

    // Remember the image.
    g_images.push(image);
  }

  g_intervalId = window.setInterval(renderHandler, 1000/60);
}

function renderHandler() {
  // draw with textures.
  // ...
}

function imageLoadedHandler(image) {
  // Mark the image as loaded.
  image.loaded = true;

  // Copy the image to the texture.
  updateTexture(image);
}

function updateTexture(image) {
  if (!g_gl.isContextLost() &amp;&amp; image.loaded) {
    g_gl.bindTexture(g_gl.TEXTURE_2D, image.texture);
    g_gl.texImage2D(g_gl.TEXTURE_2D, 0, image);
  }
}

function contextLostHandler() {
  // stop rendering.
  window.clearInterval(g_internvalId);
}

function contextRestoredHandler() {
  // create new textures for all images and restore their contents.
  for (var ii = 0; ii &lt; g_images.length; ++ii) {
    g_images[ii].texture = g_gl.createTexture();
    updateTexture(g_images[ii]);
  }

  // Start rendering again.
  g_intervalId = window.setInterval(renderHandler, 1000/60);
}
    </pre>
    </div>

<!-- ======================================================================================================= -->

    <h2 id="6"><span class="secno">6</span> Differences Between WebGL and OpenGL ES 2.0</h2>
    
<p>

This section describes changes made to the WebGL API relative to the OpenGL ES 2.0 API to improve
portability across various operating systems and devices.

</p>

    <h3 id="6.1"><span class="secno">6.1</span> Buffer Object Binding</h3>

<p>

In the WebGL API, a given buffer object may only be bound to one of the <code>ARRAY_BUFFER</code> or
<code>ELEMENT_ARRAY_BUFFER</code> binding points in its lifetime. This restriction implies that a
given buffer object may contain either vertices or indices, but not both.

</p>
<p>

The type of a WebGLBuffer is initialized the first time it is passed as an argument
to <code>bindBuffer</code>. A subsequent call to <code>bindBuffer</code> which attempts to bind the
same WebGLBuffer to the other binding point will generate an <code>INVALID_OPERATION</code> error, and
the state of the binding point will remain untouched.

</p>

    <h3 id="6.2"><span class="secno">6.2</span> <a name="ATTRIBS_AND_RANGE_CHECKING">Enabled Vertex Attributes and Range Checking</a></h3>

<p>

If a vertex attribute is enabled as an array via <code>enableVertexAttribArray</code> but no buffer
is bound to that attribute via <code>bindBuffer</code> and <code>vertexAttribPointer</code>, then
calls to <code>drawArrays</code> or <code>drawElements</code> will generate an
<code>INVALID_OPERATION</code> error.

</p>
<p>

If a vertex attribute is enabled as an array, a buffer is bound to that attribute, and the attribute
is consumed by the current program, then calls to <code>drawArrays</code>
and <code>drawElements</code> will verify that each referenced vertex lies within the storage of the
bound buffer. If the range specified in <code>drawArrays</code> or any referenced index
in <code>drawElements</code> lies outside the storage of the bound buffer, an INVALID_OPERATION
error is generated and no geometry is drawn.

</p>
<p>

If a vertex attribute is enabled as an array, a buffer is bound to that attribute, but the attribute
is not consumed by the current program, then regardless of the size of the bound buffer, it will not
cause any error to be generated during a call to <code>drawArrays</code>
or <code>drawElements</code>.

</p>

    <h3 id="6.3"><span class="secno">6.3</span> Framebuffer Object Attachments</h3>

<p>

WebGL adds the <code>DEPTH_STENCIL_ATTACHMENT</code> framebuffer object attachment point and
the <code>DEPTH_STENCIL</code> renderbuffer internal format. To attach both depth and stencil
buffers to a framebuffer object, call <code>renderbufferStorage</code> with
the <code>DEPTH_STENCIL</code> internal format, and then call <code>framebufferRenderbuffer</code>
with the <code>DEPTH_STENCIL_ATTACHMENT</code> attachment point.

</p>
<p>

A renderbuffer attached to the <code>DEPTH_ATTACHMENT</code> attachment point must be allocated with
the <code>DEPTH_COMPONENT16</code> internal format. A renderbuffer attached to
the <code>STENCIL_ATTACHMENT</code> attachment point must be allocated with
the <code>STENCIL_INDEX8</code> internal format. Attempts to attach a renderbuffer with an incorrect
internal format to a particular attachment point will generate an <code>INVALID_OPERATION</code> error from the call
to <code>framebufferRenderbuffer</code> and leave the framebuffer's attachments untouched.

</p>
<p>

In the WebGL API, it is an error to concurrently attach renderbuffers to the following combinations
of attachment points:

</p><ul>
<li> <code>DEPTH_ATTACHMENT + DEPTH_STENCIL_ATTACHMENT</code>
</li><li> <code>STENCIL_ATTACHMENT + DEPTH_STENCIL_ATTACHMENT</code>
</li><li> <code>DEPTH_ATTACHMENT + STENCIL_ATTACHMENT</code>
</li></ul>

A call to <code>framebufferRenderbuffer</code> which would result in non-zero attachments to any of
these combinations of attachment points will generate an <code>INVALID_OPERATION</code> error and leave
the framebuffer's attachments untouched.

<p></p>

    <h3 id="6.4"><span class="secno">6.4</span> <a name="PIXEL_STORAGE_PARAMETERS">Pixel Storage Parameters</a></h3>

<p>

The WebGL API supports the following two additional boolean parameters to <code>pixelStorei</code>.
Any non-zero <em>param</em> is interpreted as the value <code>true</code>.

</p><dl>
<dt><code>UNPACK_FLIP_Y_WEBGL</code>
</dt><dd>If set, then during any subsequent calls to <code>texImage2D</code> or
<code>texSubImage2D</code>, the source data is flipped along the vertical axis, so that conceptually
the last row is the first one transferred. The default value is <code>false</code>.

</dd><dt><code>UNPACK_PREMULTIPLY_ALPHA_WEBGL</code>
</dt><dd>If set, then during any subsequent calls to <code>texImage2D</code>
or <code>texSubImage2D</code>, the alpha channel of the source data, if present, is multiplied into
the color channels during the data transfer. The default value is <code>false</code>.
</dd></dl>

<p></p>

    <h3 id="6.5"><span class="secno">6.5</span> <a name="STENCIL_SEPARATE_LIMIT">Stencil Separate Mask and Reference Value</a></h3>

<p>
In the WebGL API it is illegal to specify a different mask or reference value for front facing and
back facing triangles in stencil operations. A call to <code>stencilMaskSeparate</code> will generate an
<code>INVALID_OPERATION</code> error if <code>FRONT</code> mask is not equal to <code>BACK</code>
mask. Similarly, a call to <code>stencilFuncSeparate</code> will generate an
<code>INVALID_OPERATION</code> error if <code>FRONT</code> ref is not equal to <code>BACK</code> ref
or <code>FRONT</code> mask is not equal to <code>BACK</code> mask. 
</p>

    <h3 id="6.6"><span class="secno">6.6</span> <a name="VERTEX_STRIDE">Vertex Attribute Data Stride</a></h3>

<p>
The WebGL API supports vertex attribute data strides up to 255 bytes. A call to
<code>vertexAttribPointer</code> will generate an <code>INVALID_VALUE</code> error if the value for
the stride parameter exceeds 255.
</p>

    <h3 id="6.7"><span class="secno">6.7</span> <a name="VIEWPORT_DEPTH_RANGE">Viewport Depth Range</a></h3>

<p>
The WebGL API does not support depth ranges with where the near plane is mapped to a value greater
than that of the far plane. A call to <code>depthRange</code> will generate an
<code>INVALID_OPERATION</code> error if <code>zNear</code> is greater than <code>zFar</code>.
</p>

    <h3 id="6.8"><span class="secno">6.8</span> <a name="CONSTANT_COLOR_BLEND">Blending With Constant Color</a></h3>

<p>
In the WebGL API, constant color and constant alpha cannot be used together as source and
destination factors in the blend function. A call to <code>blendFunc</code> will generate an
<code>INVALID_OPERATION</code> error if one of the two factors is set to <code>CONSTANT_COLOR</code>
or <code>ONE_MINUS_CONSTANT_COLOR</code> and the other to <code>CONSTANT_ALPHA</code> or
<code>ONE_MINUS_CONSTANT_ALPHA</code>. A call to <code>blendFuncSeparate</code> will generate an
<code>INVALID_OPERATION</code> error if <code>srcRGB</code> is set to <code>CONSTANT_COLOR</code>
or <code>ONE_MINUS_CONSTANT_COLOR</code> and <code>dstRGB</code> is set to <code>CONSTANT_ALPHA</code> or
<code>ONE_MINUS_CONSTANT_ALPHA</code> or vice versa.
</p>

    <h3 id="6.9"><span class="secno">6.9</span> Fixed point support</h3>

The WebGL API does not support the <code>GL_FIXED</code> data type.

    <h3 id="6.10"><span class="secno">6.10</span> GLSL Constructs</h3>

<p>
Per <a href="#SUPPORTED_GLSL_CONSTRUCTS">Supported GLSL Constructs</a>, identifiers starting with
"webgl_" and "_webgl_" are reserved for use by WebGL.
</p>

    <h3 id="6.11"><span class="secno">6.11</span> <a name="EXTENSION_QUERIES">Extension Queries</a></h3>

<p>

In the OpenGL ES 2.0 API, the available extensions are determined by calling
<code>glGetString(GL_EXTENSIONS)</code>, which returns a space-separated list of extension strings.
In the WebGL API, <code>EXTENSIONS</code> is not a legal argument to <code>getParameter</code>.
Instead, <code>getSupportedExtensions</code> must be called to determine the set of available
extensions.

</p>

<!-- ======================================================================================================= -->

    <h2 id="7"><span class="secno">7</span> References</h2>
    
    <h3 id="7.1"><span class="secno">7.1</span> Normative references</h3>
    <dl>
    
        <dt id="refsTYPEDARRAYS">[TYPEDARRAYS]</dt>
        <dd><cite><a href="https://cvs.khronos.org/svn/repos/registry/trunk/public/webgl/doc/spec/TypedArray-spec.html">
            Typed Array Specification: Editor's Draft</a></cite>,
            V. Vukicevic, K. Russell, May 2010.
        </dd>
        <dt id="refsGLES20">[GLES20]</dt>
        <dd><cite><a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.24.pdf">
            OpenGL® ES Common Profile Specification Version 2.0.24</a></cite>, 
            A. Munshi, J. Leech, April 2009.
        </dd>
        <dt id="refsGLES20GLSL">[GLES20GLSL]</dt>
        <dd><cite><a href="http://www.khronos.org/registry/gles/specs/2.0/GLSL_ES_Specification_1.0.17.pdf">
            The OpenGL® ES Shading Language Version 1.00</a></cite>, 
            R. Simpson, May 2009.
        </dd>
        <dt id="refsRFC2119">[RFC2119]</dt>
        <dd><cite><a href="http://www.ietf.org/rfc/rfc2119.txt">
            Key words for use in RFCs to Indicate Requirement Levels</a></cite>,
            S. Bradner. IETF, March 1997.
        </dd>
        <dt id="refsWEBIDL">[WEBIDL]</dt>
        <dd><cite><a href="http://dev.w3.org/2006/webapi/WebIDL/">
            Web IDL: W3C Editor’s Draft</a></cite>, 
            C. McCormack, September 2009.
        </dd>
    </dl>

    <h3 id="7.2"><span class="secno">7.2</span> Other references</h3>

<!-- ======================================================================================================= -->
    
    <h2 id="8"><span class="secno">8</span> Acknowledgments</h2>
    <p>This specification is produced by the Khronos WebGL Working Group.</p>
    
    <p>
       Special thanks to: Arun Ranganathan (Mozilla), Jon Leech, Kenneth Russell (Google), 
       Kenneth Waters (Google), Mark Callow (HI), Mark Steele (Mozilla), Oliver Hunt (Apple), 
       Tim Johansson (Opera), Vangelis Kokkevis (Google), Vladimir Vukicevic (Mozilla),
       Gregg Tavares (Google)
    </p>
    <p>
        Additional thanks to: Alan Hudson (Yumetech), Bill Licea Kane (AMD), Cedric Vivier (Zegami),
        Dan Gessel (Apple), David Ligon (Qualcomm), Greg Ross (Nvidia), Jacob Strom (Ericsson), Kari Pulli (Nokia),
        Leddie Stenvie (ST-Ericsson), Neil Trevett (Nvidia), Per Wennersten (Ericsson),
        Per-Erik Brodin (Ericsson), Shiki Okasaka (Google), Tom Olson (ARM), Zhengrong Yao (Ericsson),
        and the members of the Khronos WebGL Working Group.
</p>



</body></html>
